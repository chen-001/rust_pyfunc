<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust PyFunc API文档</title>
    <link rel="stylesheet" href="static/style.css">
    <script src="static/search.js"></script>
</head>
<body>
    <div class="navbar">
        <h1 class="navbar-title">Rust PyFunc</h1>
        <p class="navbar-subtitle">高性能Python函数集合 - API文档</p>
    </div>
    
    
<div class="container">
    <div class="sidebar">
        <div class="search-container">
            <input type="text" id="search-input" placeholder="搜索函数...">
            <div id="search-results"></div>
        </div>
        
        <h2>函数分类</h2>
        <ul class="function-list">
            <li><a href="#text">文本处理</a></li>
            <li><a href="#sequence">序列分析</a></li>
            <li><a href="#statistics">统计分析</a></li>
            <li><a href="#time_series">时间序列</a></li>
            <li><a href="#other">其他函数</a></li>
        </ul>
    </div>
    
    <div class="content">
        <h1>API 文档</h1>
        <p>本文档提供了Rust PyFunc库中所有公开函数的详细说明和使用示例。这些示例基于真实的Python运行结果生成。</p>
        
        <div id="text" class="category">
            <h2 class="category-title">文本处理函数</h2>
            
            <div class="function-item">
                <h3 class="function-name"><a href="jaccard_similarity.html">jaccard_similarity</a></h3>
                <div><p>计算两个句子之间的Jaccard相似度。
Jaccard相似度是两个集合交集大小除以并集大小，用于衡量两个句子的相似程度。
这里将每个句子视为单词集合，忽略单词出现的顺序和频率。</p></div>
                <a href="jaccard_similarity.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="min_word_edit_distance.html">min_word_edit_distance</a></h3>
                <div><p>计算将一个句子转换为另一个句子所需的最少单词操作次数（添加/删除）。</p>
<h1>参数</h1>
<ul>
<li><code>str1</code> - 源句子</li>
<li><code>str2</code> - 目标句子</li>
</ul>
<h1>示例</h1>
<p>```python
from rust_pyfunc import min_word_edit_distance</p>
<h1>示例1：添加一个单词</h1>
<p>da = "We expect demand to increase"
db = "We expect worldwide demand to increase"
print(min_word_edit_distance(da, db))  # 输出: 1 (添加 "worldwide")</p>
<h1>示例2：多次修改</h1>
<p>dc = "We expect weakness in sales"
print(min_word_edit_distance(da, dc))  # 输出: 6 (删除3个单词，添加3个单词)
```</p></div>
                <a href="min_word_edit_distance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="vectorize_sentences.html">vectorize_sentences</a></h3>
                <div><p>将两个句子转换为词频向量。
生成的向量长度相同，等于两个句子中不同单词的总数。
向量中的每个位置对应一个单词，值表示该单词在句子中出现的次数。</p></div>
                <a href="vectorize_sentences.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="vectorize_sentences_list.html">vectorize_sentences_list</a></h3>
                <div><p>将多个句子转换为词频向量列表。
生成的所有向量长度相同，等于所有句子中不同单词的总数。
每个向量中的每个位置对应一个单词，值表示该单词在对应句子中出现的次数。</p></div>
                <a href="vectorize_sentences_list.html">查看详情</a>
            </div>
            
        </div>
        
        <div id="sequence" class="category">
            <h2 class="category-title">序列分析函数</h2>
            
            <div class="function-item">
                <h3 class="function-name"><a href="compute_allo_microstructure_features.html">compute_allo_microstructure_features</a></h3>
                <div><p>计算非对称大挂单微观结构特征</p></div>
                <a href="compute_allo_microstructure_features.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="compute_allo_microstructure_features_tris_expanded.html">compute_allo_microstructure_features_tris_expanded</a></h3>
                <div><p>计算非对称大挂单微观结构特征 - tris扩展版本</p>
<p>此函数专门用于detection_mode="tris"且side_filter="tris"的场景，
返回9种参数组合的原始事件特征，而非均值</p></div>
                <a href="compute_allo_microstructure_features_tris_expanded.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="compute_max_eigenvalue.html">compute_max_eigenvalue</a></h3>
                <div><p>计算二维方阵的最大特征值和对应的特征向量
使用幂迭代法计算，不使用并行计算</p></div>
                <a href="compute_max_eigenvalue.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="compute_non_breakthrough_stats.html">compute_non_breakthrough_stats</a></h3>
                <div><p>计算股票逐笔成交数据中"价格未突破上一分钟价格范围"的24个统计指标</p>
<p>参数:
exchtime: 成交时间(纳秒)
volume: 成交量(支持浮点数)
price: 成交价格
flag: 主动买卖标识(66=主买, 83=主卖)</p>
<p>返回:
(n×24的二维数组, 24个中文列名)</p></div>
                <a href="compute_non_breakthrough_stats.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="compute_price_cycle_features_b_segments_enhanced.html">compute_price_cycle_features_b_segments_enhanced</a></h3>
                <div><p>无文档</p></div>
                <a href="compute_price_cycle_features_b_segments_enhanced.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="find_follow_volume_sum_same_price.html">find_follow_volume_sum_same_price</a></h3>
                <div><p>计算每一行在其后time_window秒内具有相同volume（及可选相同price）的行的volume总和。</p></div>
                <a href="find_follow_volume_sum_same_price.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="find_follow_volume_sum_same_price_and_flag.html">find_follow_volume_sum_same_price_and_flag</a></h3>
                <div><p>无文档</p></div>
                <a href="find_follow_volume_sum_same_price_and_flag.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="find_half_energy_time.html">find_half_energy_time</a></h3>
                <div><p>计算每个时间点价格达到时间窗口内最终能量一半所需的时间。</p>
<p>该函数首先计算时间窗口结束时的能量（价格变动的绝对值比率），
然后计算第一次达到该能量一半所需的时间。</p>
<h1>参数说明</h1>
<ul>
<li><code>times</code> - 时间戳数组（单位：秒）</li>
<li><code>prices</code> - 价格数组</li>
<li><code>time_window</code> - 时间窗口大小（单位：秒），默认为5.0</li>
</ul>
<h1>返回值</h1>
<p>浮点数数组，表示每个时间点达到最终能量一半所需的时间（秒）。
如果在时间窗口内未达到一半能量，则返回time_window值。
如果最终能量为0，则返回0。</p>
<h1>特殊情况处理</h1>
<ul>
<li>当价格为NaN或Inf时，对应结果为NaN</li>
<li>当最终能量为0时，结果为0</li>
<li>当时间窗口内无法计算出最终能量时，结果为time_window</li>
</ul>
<h1>性能</h1>
<p>该函数使用并行处理加速计算，在大规模数据集上比等效的Python实现快约20-100倍。</p>
<h1>示例</h1>
<p>```python
import pandas as pd
import numpy as np
from rust_pyfunc import find_half_energy_time</p>
<h1>创建示例DataFrame</h1>
<p>df = pd.DataFrame({
    'exchtime': [1.0, 1.1, 1.2, 1.3, 1.4],
    'price': [10.0, 10.2, 10.5, 10.3, 10.1]
})</p>
<h1>计算达到一半能量所需时间</h1>
<p>df['half_energy_time'] = find_half_energy_time(
    df['exchtime'].values,
    df['price'].values,
    time_window=5.0
)
print(df)
```</p></div>
                <a href="find_half_energy_time.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="find_half_extreme_time.html">find_half_extreme_time</a></h3>
                <div><p>计算每一行在其后指定时间窗口内的价格变动能量，并找出首次达到最终能量一半时所需的时间。</p></div>
                <a href="find_half_extreme_time.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="find_local_peaks_within_window.html">find_local_peaks_within_window</a></h3>
                <div><p>查找时间序列中价格在指定时间窗口内为局部最大值的点。</p></div>
                <a href="find_local_peaks_within_window.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="find_max_range_product.html">find_max_range_product</a></h3>
                <div><p>在数组中找到一对索引(x, y)，使得min(arr[x], arr[y]) * |x-y|的值最大。
这个函数可以用来找到数组中距离最远的两个元素，同时考虑它们的最小值。</p></div>
                <a href="find_max_range_product.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="identify_segments.html">identify_segments</a></h3>
                <div><p>识别数组中的连续相等值段，并为每个段分配唯一标识符。
每个连续相等的值构成一个段，第一个段标识符为1，第二个为2，以此类推。</p></div>
                <a href="identify_segments.html">查看详情</a>
            </div>
            
        </div>
        
        <div id="statistics" class="category">
            <h2 class="category-title">统计分析函数</h2>
            
            <div class="function-item">
                <h3 class="function-name"><a href="PriceTree.html">PriceTree</a></h3>
                <div><p>无文档</p></div>
                <a href="PriceTree.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="PriceTreeViz.html">PriceTreeViz</a></h3>
                <div><p>无文档</p></div>
                <a href="PriceTreeViz.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="RollingFutureAccessor.html">RollingFutureAccessor</a></h3>
                <div><p>用于在pandas DataFrame或Series上实现向后滚动窗口计算的访问器。</p>
<h2>支持的统计量类型：</h2>
<ul>
<li>mean: 计算后面窗口内的均值</li>
<li>sum: 计算后面窗口内的总和</li>
<li>max: 计算后面窗口内的最大值</li>
<li>min: 计算后面窗口内的最小值</li>
<li>std: 计算后面窗口内的标准差</li>
<li>median: 计算后面窗口内的中位数</li>
<li>count: 计算后面窗口内的数据点数量</li>
<li>rank: 计算当前值在后面窗口内的分位数（0到1之间）</li>
<li>skew: 计算后面窗口的偏度</li>
<li>trend_time: 计算后面窗口内数据序列与时间序列的相关系数</li>
<li>trend_oneton: 计算后面窗口内数据序列与1到n序列的相关系数（忽略时间间隔）</li>
<li>last: 计算后面窗口内的最后一个值</li>
</ul>
<p>注意：所有计算都不包括当前时间点的值，只考虑后面窗口内的值</p>
<h2>使用方法：</h2>
<blockquote>
<blockquote>
<blockquote>
<p>import pandas as pd
from rust_pyfunc import rolling_future</p>
<h1>DataFrame示例</h1>
<p>df = pd.DataFrame({
...     'time': pd.date_range('2024-01-01', periods=5, freq='s'),
...     'value': [1, 2, 3, 4, 5]
... })
df.set_index('time', inplace=True)
df.rolling_future('2s').mean()  # 计算每个时间点之后2秒内的均值
df.rolling_future('2s').rank()  # 计算每个值在后面2秒内的分位数</p>
<h1>Series示例</h1>
<p>s = pd.Series([1, 2, 3, 4, 5], 
...               index=pd.date_range('2024-01-01', periods=5, freq='s'))
s.rolling_future('2s').mean()  # 计算每个时间点之后2秒内的均值
s.rolling_future('2s').trend_time()  # 计算后面2秒内的趋势</p>
</blockquote>
</blockquote>
</blockquote></div>
                <a href="RollingFutureAccessor.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="RollingPastAccessor.html">RollingPastAccessor</a></h3>
                <div><p>用于在pandas DataFrame或Series上实现向前滚动窗口计算的访问器。</p>
<h2>支持的统计量类型：</h2>
<ul>
<li>mean: 计算前面窗口内的均值</li>
<li>sum: 计算前面窗口内的总和</li>
<li>max: 计算前面窗口内的最大值</li>
<li>min: 计算前面窗口内的最小值</li>
<li>std: 计算前面窗口内的标准差</li>
<li>median: 计算前面窗口内的中位数</li>
<li>count: 计算前面窗口内的数据点数量</li>
<li>rank: 计算当前值在前面窗口内的分位数（0到1之间）</li>
<li>skew: 计算前面窗口的偏度</li>
<li>trend_time: 计算前面窗口内数据序列与时间序列的相关系数</li>
<li>trend_oneton: 计算前面窗口内数据序列与1到n序列的相关系数（忽略时间间隔）</li>
<li>first: 计算前面窗口内的第一个值</li>
<li>last: 计算前面窗口内的最后一个值</li>
</ul>
<p>注意：所有计算都可以选择是否包括当前时间点的值</p>
<h2>使用方法：</h2>
<blockquote>
<blockquote>
<blockquote>
<p>import pandas as pd
from rust_pyfunc import rolling_past</p>
<h1>DataFrame示例</h1>
<p>df = pd.DataFrame({
...     'time': pd.date_range('2024-01-01', periods=5, freq='s'),
...     'value': [1, 2, 3, 4, 5]
... })
df.set_index('time', inplace=True)
df.rolling_past('2s').mean()  # 计算每个时间点之前2秒内的均值
df.rolling_past('2s').first()  # 计算每个时间点之前2秒内的第一个值</p>
<h1>Series示例</h1>
<p>s = pd.Series([1, 2, 3, 4, 5], 
...               index=pd.date_range('2024-01-01', periods=5, freq='s'))
s.rolling_past('2s').mean()  # 计算每个时间点之前2秒内的均值
s.rolling_past('2s').trend_time()  # 计算前面2秒内的趋势</p>
</blockquote>
</blockquote>
</blockquote></div>
                <a href="RollingPastAccessor.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="analyze_asks.html">analyze_asks</a></h3>
                <div><p>异常挂单区间特征提取器</p>
<p>输入</p></div>
                <a href="analyze_asks.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="analyze_hawkes_indicators.html">analyze_hawkes_indicators</a></h3>
                <div><p>Analyze Hawkes process indicators and provide trading advice</p>
<p>This function analyzes Hawkes model output metrics, automatically analyzes
market microstructure features, and provides quantitative trading and strategy suggestions.</p></div>
                <a href="analyze_hawkes_indicators.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="analyze_long_orders.html">analyze_long_orders</a></h3>
                <div><p>分析漫长订单并计算比值</p>
<p>参数:
- exchtime: 交易时间数组(纳秒)
- order: 订单编号数组
- volume: 成交量数组
- top_ratio: 可选参数，表示只计算最漫长的一部分订单的比例(0.0-1.0)
             默认为1.0表示计算所有订单，0.5表示只计算最漫长的一半订单</p>
<p>返回: (时间漫长比值序列, 次数漫长比值序列, 两者都漫长比值序列,
      时间漫长总比值, 次数漫长总比值, 两者都漫长总比值)</p></div>
                <a href="analyze_long_orders.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="analyze_long_orders_python.html">analyze_long_orders_python</a></h3>
                <div><p>Python版本的漫长订单分析(用于测试对比)</p></div>
                <a href="analyze_long_orders_python.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="analyze_retreat_advance.html">analyze_retreat_advance</a></h3>
                <div><p>分析股票交易中的"以退为进"现象</p>
<p>该函数分析当价格触及某个局部高点后回落，然后在该价格的异常大挂单量消失后
成功突破该价格的现象。</p></div>
                <a href="analyze_retreat_advance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="analyze_retreat_advance_v2.html">analyze_retreat_advance_v2</a></h3>
                <div><p>分析股票交易中的"以退为进"现象（纳秒版本）</p>
<p>该函数分析当价格触及某个局部高点后回落，然后在该价格的异常大挂单量消失后
成功突破该价格的现象。该版本包含局部高点去重功能，避免在同一价格水平的
连续成交中重复识别相同的"以退为进"过程。</p></div>
                <a href="analyze_retreat_advance_v2.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="analyze_sequence_permutations_v0816_fixed.html">analyze_sequence_permutations_v0816_fixed</a></h3>
                <div><p>无文档</p></div>
                <a href="analyze_sequence_permutations_v0816_fixed.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="batch_factor_neutralization_io_optimized.html">batch_factor_neutralization_io_optimized</a></h3>
                <div><p>I/O优化的批量因子中性化函数</p></div>
                <a href="batch_factor_neutralization_io_optimized.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="brachistochrone_curve.html">brachistochrone_curve</a></h3>
                <div><p>计算最速曲线（投掷线）并返回x_series对应的y坐标</p></div>
                <a href="brachistochrone_curve.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="brachistochrone_curve_v2.html">brachistochrone_curve_v2</a></h3>
                <div><p>修正版最速曲线函数，确保终点严格一致  </p>
<p>此函数解决了原版brachistochrone_curve终点不一致的问题
通过强制约束终点坐标，确保数学正确性</p></div>
                <a href="brachistochrone_curve_v2.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_base_entropy.html">calculate_base_entropy</a></h3>
                <div><p>计算基准熵 - 基于到当前时间点为止的订单分布计算香农熵</p>
<p>参数:
* exchtime: 交易时间数组（纳秒时间戳）
* order: 订单号数组
* volume: 成交量数组
* index: 计算熵值的当前索引位置</p>
<p>返回:
* 基准熵值</p></div>
                <a href="calculate_base_entropy.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_binned_entropy_1d.html">calculate_binned_entropy_1d</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_binned_entropy_1d.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_binned_entropy_2d.html">calculate_binned_entropy_2d</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_binned_entropy_2d.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_effective_memory_length.html">calculate_effective_memory_length</a></h3>
                <div><p>基于信息论的有效记忆长度(EML)计算 - 针对成交量序列优化</p>
<h1>参数</h1>
<ul>
<li><code>data</code> - 成交量或其他一维数据序列 (numpy array)</li>
<li><code>window_size</code> - 统计窗口大小</li>
<li><code>max_lag</code> - 最大回顾长度</li>
<li><code>threshold_ratio</code> - 满意度阈值比例, 默认0.9 (90%)</li>
<li><code>quantile</code> - 离散化分位数, 默认0.5 (中位数)</li>
</ul>
<h1>返回</h1>
<ul>
<li>有效记忆长度 (eml)</li>
</ul>
<h1>离散化方法</h1>
<p>将数据按指定分位数二值化：
- 大于分位数: 1 (高成交量)
- 小于等于分位数: 0 (低成交量)</p>
<h1>分位数说明</h1>
<ul>
<li>quantile=0.5: 中位数分割 (默认)</li>
<li>quantile=0.9: 90%分位数分割，只有前10%最高成交量为1</li>
<li>quantile=0.1: 10%分位数分割，只有前10%最低成交量为1</li>
</ul></div>
                <a href="calculate_effective_memory_length.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_entropy_1d.html">calculate_entropy_1d</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_entropy_1d.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_entropy_2d.html">calculate_entropy_2d</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_entropy_2d.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_entropy_discrete_1d.html">calculate_entropy_discrete_1d</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_entropy_discrete_1d.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_entropy_discrete_2d.html">calculate_entropy_discrete_2d</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_entropy_discrete_2d.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_ghost_market_maker_factor_rust.html">calculate_ghost_market_maker_factor_rust</a></h3>
                <div><p>计算幽灵做市商因子（Ghost Market Maker's Regret）</p>
<p>核心逻辑：强制割裂买卖两侧的联动，测量盘口僵硬度
通过计算买卖盘口之间的"量子纠缠程度"来识别变盘信号</p>
<p>参数:
    bid_ask_volumes: 买卖盘量矩阵 (n_samples, 20)
                     前10列为买方量(bid_vol1-10)，后10列为卖方量(ask_vol1-10)
    window: 计算协方差的窗口大小</p>
<p>返回:
    因子值，衡量买卖盘口的量子纠缠程度</p></div>
                <a href="calculate_ghost_market_maker_factor_rust.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_large_order_nearby_small_order_time_gap.html">calculate_large_order_nearby_small_order_time_gap</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_large_order_nearby_small_order_time_gap.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_lyapunov_exponent.html">calculate_lyapunov_exponent</a></h3>
                <div><p>统一的Lyapunov指数计算函数</p></div>
                <a href="calculate_lyapunov_exponent.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_order_time_gap_and_price_percentile_ultra_sorted.html">calculate_order_time_gap_and_price_percentile_ultra_sorted</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_order_time_gap_and_price_percentile_ultra_sorted.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_order_time_gap_and_price_percentile_ultra_sorted_bucketed.html">calculate_order_time_gap_and_price_percentile_ultra_sorted_bucketed</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_order_time_gap_and_price_percentile_ultra_sorted_bucketed.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_order_time_gap_and_price_percentile_ultra_sorted_v2.html">calculate_order_time_gap_and_price_percentile_ultra_sorted_v2</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_order_time_gap_and_price_percentile_ultra_sorted_v2.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_order_time_gap_and_price_percentile_ultra_sorted_v2_bucketed.html">calculate_order_time_gap_and_price_percentile_ultra_sorted_v2_bucketed</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_order_time_gap_and_price_percentile_ultra_sorted_v2_bucketed.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_order_time_gap_and_price_percentile_ultra_sorted_v3.html">calculate_order_time_gap_and_price_percentile_ultra_sorted_v3</a></h3>
                <div><p>计算订单时间间隔和价格分位数的超高性能版本V3</p>
<h1>参数</h1>
<ul>
<li>volume: 交易volume数组</li>
<li>exchtime: 交易所时间戳数组（纳秒）</li>
<li>price: 交易价格数组</li>
<li>flag: 交易标志数组（V3版本中忽略）</li>
<li>ask_order: 卖单订单号数组</li>
<li>bid_order: 买单订单号数组</li>
<li>min_count: 最小计算记录数</li>
<li>use_flag: 计算策略 ("same"/"diff"/"ignore")</li>
</ul>
<h1>返回值</h1>
<ul>
<li>(结果数组, 列名列表)：结果数组形状为(n, 27)</li>
</ul></div>
                <a href="calculate_order_time_gap_and_price_percentile_ultra_sorted_v3.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_order_time_gap_and_price_percentile_ultra_sorted_v6.html">calculate_order_time_gap_and_price_percentile_ultra_sorted_v6</a></h3>
                <div><p>V6版本：大数据优化的订单时间间隔和价格分位数计算
核心优化：
1. 使用预排序时间索引进行二分查找
2. 线性搜索价格分位数避免排序开销
3. 内存预分配减少动态分配
4. 算法复杂度从O(n² log n)降低到O(n log n)</p></div>
                <a href="calculate_order_time_gap_and_price_percentile_ultra_sorted_v6.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_passive_order_features.html">calculate_passive_order_features</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_passive_order_features.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_shannon_entropy_change.html">calculate_shannon_entropy_change</a></h3>
                <div><p>计算价格变化后的香农熵变</p></div>
                <a href="calculate_shannon_entropy_change.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_shannon_entropy_change_at_low.html">calculate_shannon_entropy_change_at_low</a></h3>
                <div><p>在价格创新低时计算香农熵变</p>
<p>参数:
* exchtime: 交易时间数组
* order: 订单号数组
* volume: 成交量数组
* price: 价格数组
* window_seconds: 时间窗口大小（秒）
* bottom_k: 如果提供，则只计算价格最低的k个点的熵变，默认为None（计算所有价格创新低点）</p>
<p>返回:
* 香农熵变数组，只在价格创新低时有值，其他位置为NaN</p></div>
                <a href="calculate_shannon_entropy_change_at_low.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_trade_price_statistics_by_volume.html">calculate_trade_price_statistics_by_volume</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_trade_price_statistics_by_volume.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_trade_price_statistics_by_volume_bucketed.html">calculate_trade_price_statistics_by_volume_bucketed</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_trade_price_statistics_by_volume_bucketed.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_trade_price_statistics_by_volume_bucketed_v3.html">calculate_trade_price_statistics_by_volume_bucketed_v3</a></h3>
                <div><p>优化版本：极致性能的分桶统计计算函数（V3）</p>
<p>针对13万数据量快速完成的极致优化版本
核心思路：预排序 + 批量处理，避免对每个记录单独排序</p>
<h1>🚀 核心优化：</h1>
<ul>
<li>在volume组级别预排序时间索引</li>
<li>使用二分查找定位邻近记录</li>
<li>批量计算所有百分比档位</li>
<li>部分排序（只排序需要的元素）</li>
</ul></div>
                <a href="calculate_trade_price_statistics_by_volume_bucketed_v3.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_trade_price_statistics_by_volume_optimized.html">calculate_trade_price_statistics_by_volume_optimized</a></h3>
                <div><p>优化版本的计算同体量同方向成交的价格统计指标</p>
<p>该函数是 calculate_trade_price_statistics_by_volume 的高性能版本，
通过预排序索引、二分查找和批量处理等优化技术大幅提升计算速度。</p>
<h1>🚀 性能优化特点：</h1>
<ul>
<li>预排序时间索引，避免重复排序操作</li>
<li>二分查找快速定位最近成交记录</li>
<li>批量计算统计量，避免重复数值计算</li>
<li>内存访问优化，减少分配开销</li>
<li>算法复杂度从O(n²)优化到O(n log n)</li>
</ul>
<h1>💡 适用场景：</h1>
<ul>
<li>高频交易数据分析</li>
<li>大规模历史数据处理</li>
<li>实时价格统计计算</li>
<li>性能敏感的量化研究</li>
</ul></div>
                <a href="calculate_trade_price_statistics_by_volume_optimized.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_trade_price_statistics_by_volume_order_level.html">calculate_trade_price_statistics_by_volume_order_level</a></h3>
                <div><p>计算订单聚合后的VWAP价格统计指标（订单级别输出版本）</p>
<p>该函数与 calculate_trade_price_statistics_by_volume_v2 的逻辑相同，
但返回订单级别的结果，避免同一订单的多笔成交产生重复数据。</p>
<h1>🎯 核心特点：</h1>
<ul>
<li>订单级别输出：每个订单返回一行统计指标</li>
<li>避免数据重复：同一订单的多笔成交不会产生重复结果</li>
<li>VWAP计算：使用订单的成交量加权平均价格</li>
<li>基于订单类型：通过ask_order/bid_order区分买卖方向</li>
</ul>
<h1>📊 输出结构：</h1>
<ul>
<li>means数组：num_orders行10列，每行对应一个订单的VWAP价格均值</li>
<li>stds数组：num_orders行10列，每行对应一个订单的VWAP价格标准差</li>
<li>column_names：20个列名（10个均值+10个标准差）</li>
</ul>
<h1>🔄 订单聚合逻辑：</h1>
<ul>
<li>卖单（ask_order != 0）：基于ask_order聚合成交记录</li>
<li>买单（bid_order != 0）：基于bid_order聚合成交记录</li>
<li>每个订单计算：</li>
<li>总volume：累加所有成交volume</li>
<li>VWAP价格：Σ(volume × price) / Σ(volume)</li>
<li>最后时间：所有成交时间的最大值</li>
</ul></div>
                <a href="calculate_trade_price_statistics_by_volume_order_level.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_trade_price_statistics_by_volume_ultra_fast.html">calculate_trade_price_statistics_by_volume_ultra_fast</a></h3>
                <div><p>超级优化版本：极致性能的统计计算函数</p>
<p>这是 calculate_trade_price_statistics_by_volume 的终极优化版本，
专门为13万数据量1秒内完成的目标而设计。</p>
<h1>🚀 极致优化技术：</h1>
<ul>
<li>零拷贝数据访问模式</li>
<li>预排序索引，O(1)查找</li>
<li>批量统计量计算</li>
<li>内存池复用</li>
<li>SIMD向量化准备</li>
<li>缓存友好的数据布局</li>
</ul>
<h1>🎯 性能目标：</h1>
<ul>
<li>13万数据量：≤ 1秒</li>
<li>内存使用：最小化</li>
<li>算法复杂度：O(n log n) → O(n)</li>
</ul></div>
                <a href="calculate_trade_price_statistics_by_volume_ultra_fast.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_trade_price_statistics_by_volume_v2.html">calculate_trade_price_statistics_by_volume_v2</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_trade_price_statistics_by_volume_v2.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_trade_price_statistics_by_volume_v2_bucketed.html">calculate_trade_price_statistics_by_volume_v2_bucketed</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_trade_price_statistics_by_volume_v2_bucketed.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_trade_price_statistics_by_volume_v3.html">calculate_trade_price_statistics_by_volume_v3</a></h3>
                <div><p>终极优化版本：极致性能的统计计算函数（V3）</p>
<p>针对13万数据量1秒内完成的极致优化版本
核心思路：预排序 + 批量处理，避免对每个记录单独排序</p>
<h1>🚀 核心优化：</h1>
<ul>
<li>在volume组级别预排序时间索引</li>
<li>使用二分查找定位邻近记录</li>
<li>批量计算所有百分比档位</li>
<li>零额外排序开销</li>
</ul></div>
                <a href="calculate_trade_price_statistics_by_volume_v3.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_trade_time_gap_and_price_percentile_ultra_sorted.html">calculate_trade_time_gap_and_price_percentile_ultra_sorted</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_trade_time_gap_and_price_percentile_ultra_sorted.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_window_entropy.html">calculate_window_entropy</a></h3>
                <div><p>计算窗口熵 - 基于从当前时间点到未来指定时间窗口内的订单分布计算香农熵</p>
<p>参数:
* exchtime: 交易时间数组（纳秒时间戳）
* order: 订单号数组
* volume: 成交量数组
* index: 计算熵值的当前索引位置
* window_seconds: 向前查看的时间窗口大小，单位为秒</p>
<p>返回:
* 窗口熵值</p></div>
                <a href="calculate_window_entropy.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="check_string_proximity.html">check_string_proximity</a></h3>
                <div><p>计算两个字符串的接近度（最少操作次数）</p></div>
                <a href="check_string_proximity.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="check_string_proximity_matrix.html">check_string_proximity_matrix</a></h3>
                <div><p>计算字符串数组中所有字符串对之间的接近度矩阵</p></div>
                <a href="check_string_proximity_matrix.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="check_string_proximity_matrix_with_tolerance.html">check_string_proximity_matrix_with_tolerance</a></h3>
                <div><p>计算字符串数组中所有字符串对之间的接近度矩阵，支持宽限参数</p></div>
                <a href="check_string_proximity_matrix_with_tolerance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="check_string_proximity_with_tolerance.html">check_string_proximity_with_tolerance</a></h3>
                <div><p>计算两个字符串的接近度（最少操作次数），支持宽限参数</p></div>
                <a href="check_string_proximity_with_tolerance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="column_correlation_batch.html">column_correlation_batch</a></h3>
                <div><p>批量计算多列相关系数的优化版本</p>
<p>为了进一步提升性能，使用批量处理和更好的缓存局部性</p></div>
                <a href="column_correlation_batch.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="column_correlation_fast.html">column_correlation_fast</a></h3>
                <div><p>快速计算两个二维数组对应列的相关系数</p>
<p>使用高度优化的算法计算两个n×n数组对应列之间的皮尔逊相关系数。
采用Welford's online算法确保数值稳定性，优化内存访问模式以提升性能。</p></div>
                <a href="column_correlation_fast.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="corrwith.html">corrwith</a></h3>
                <div><p>计算两个DataFrame对应列或行之间的相关系数。</p>
<p>这个函数是pandas的corrwith方法的Rust实现包装，用于计算两个DataFrame中对应列（或行）
之间的皮尔逊相关系数。会自动处理两个DataFrame的列名（或行名）匹配情况。</p></div>
                <a href="corrwith.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="cosine_similarity_matrix.html">cosine_similarity_matrix</a></h3>
                <div><p>精简版余弦相似度矩阵计算（只返回余弦相似度矩阵）</p>
<p>主要优化技术：
- 零拷贝输入：使用PyReadonlyArray1避免Python到Rust的数据拷贝
- SIMD向量化：使用AVX2指令集并行计算4个元素
- 对称性优化：只计算上三角矩阵，减少一半计算量
- 直接内存操作：直接写入numpy数组内存，避免中间分配
- 缓存友好：优化内存访问模式，提高缓存命中率
- 内存优化：只返回一个矩阵，减少50%内存使用</p></div>
                <a href="cosine_similarity_matrix.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="dataframe_corrwith.html">dataframe_corrwith</a></h3>
                <div><p>计算两个数据框对应列的相关系数。</p>
<p>这个函数类似于pandas中的df.corrwith(df1)，计算两个数据框中对应列之间的皮尔逊相关系数。
相关系数范围为[-1, 1]，其中：
- 1表示完全正相关
- -1表示完全负相关
- 0表示无相关性</p></div>
                <a href="dataframe_corrwith.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="dataframe_corrwith_single_thread.html">dataframe_corrwith_single_thread</a></h3>
                <div><p>计算两个数据框对应列的相关系数（单线程版本）。</p>
<p>这个函数是 dataframe_corrwith 的单线程版本，在处理小规模数据或内存受限环境时提供更好的性能。
计算两个数据框中对应列之间的皮尔逊相关系数，不使用多线程并行处理。</p></div>
                <a href="dataframe_corrwith_single_thread.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="difference_matrix.html">difference_matrix</a></h3>
                <div><p>高性能计算差值矩阵 (SIMD优化版本)</p>
<p>输入一个一维数组，返回一个二维数组，其中第i行第j列的元素是输入数组第i个元素和第j个元素的差值</p>
<p>优化策略:
1. 使用AVX2 SIMD指令集加速向量化计算 (一次处理4个f64)
2. 优化内存访问模式提升缓存命中率
3. 循环展开减少分支预测失败
4. 内存预分配减少动态分配开销</p>
<h1>Arguments</h1>
<ul>
<li><code>data</code> - 输入的一维数组 (numpy array)</li>
</ul>
<h1>Returns</h1>
<ul>
<li><code>PyResult&lt;&amp;PyArray2&lt;f64&gt;&gt;</code> - 返回的差值矩阵</li>
</ul></div>
                <a href="difference_matrix.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="difference_matrix_memory_efficient.html">difference_matrix_memory_efficient</a></h3>
                <div><p>内存高效版本的差值矩阵计算 (针对超大矩阵优化)</p>
<p>使用分块计算策略提高缓存利用率，减少内存带宽瓶颈</p></div>
                <a href="difference_matrix_memory_efficient.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="distances_to_frontier.html">distances_to_frontier</a></h3>
                <div><p>计算收益序列中每个聚合块到马科维茨有效前沿的距离</p>
<h1>功能说明</h1>
<ol>
<li>将输入收益序列按指定大小分块聚合</li>
<li>计算块间样本协方差矩阵（带岭化保证正定性）</li>
<li>构造马科维茨无约束有效前沿</li>
<li>使用KKT-λ四次方程法计算每个资产点到前沿的最短距离</li>
</ol>
<h1>参数</h1>
<ul>
<li><code>r</code> - 1D float64数组，单日3秒频率收益序列</li>
<li><code>group_size</code> - 每多少行聚合成一块（x）</li>
<li><code>drop_last</code> - 尾部不足group_size行时是否丢弃，默认true</li>
<li><code>ddof</code> - 协方差/方差的自由度调整，默认1（样本协方差）</li>
<li><code>ridge</code> - 岭化强度系数，默认1e-6</li>
<li><code>timestamps</code> - 可选的int64时间戳数组（与<code>r</code>等长），用于标记每个聚合块的首个时间点</li>
</ul>
<h1>返回值</h1>
<p>包含两个1D数组的元组：(block_timestamps, distances)，长度均为m
- block_timestamps：每个聚合块的首个时间戳（若未提供timestamps，则返回0..m-1的序列）
- distances：对应资产点到有效前沿的距离</p>
<h1>数值提示</h1>
<p>当 m &gt;&gt; group_size 时，协方差矩阵可能秩亏，需要通过增大ridge参数保证可逆性</p>
<h1>示例</h1>
<p>```python
import numpy as np
from rust_pyfunc import distances_to_frontier</p>
<h1>生成测试数据</h1>
<p>np.random.seed(0)
r = 1e-4 * np.random.randn(4800).astype(np.float64)</p>
<h1>每1分钟聚合（20个3秒间隔）</h1>
<p>block_ts, distances = distances_to_frontier(r, group_size=20)
print(distances.shape)  # (240,)
```</p></div>
                <a href="distances_to_frontier.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="dtw_distance.html">dtw_distance</a></h3>
                <div><p>DTW（动态时间规整）是一种测量两个时间序列相似度的方法。
该算法计算两个可能长度不同、tempo不同的时间序列间的最优匹配。</p></div>
                <a href="dtw_distance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="factor_correlation_by_date.html">factor_correlation_by_date</a></h3>
                <div><p>按日期计算ret和fac的分组相关系数</p>
<h1>Arguments</h1>
<ul>
<li><code>dates</code> - 日期时间戳数组</li>
<li><code>ret</code> - 收益率数组</li>
<li><code>fac</code> - 因子值数组</li>
</ul>
<h1>Returns</h1>
<ul>
<li>(unique_dates, full_corr, low_corr, high_corr) - 四个数组</li>
<li>unique_dates: 唯一日期</li>
<li>full_corr: 每日全体数据的ret和fac排序值相关系数</li>
<li>low_corr: 每日fac小于中位数部分的ret和fac排序值相关系数</li>
<li>high_corr: 每日fac大于中位数部分的ret和fac排序值相关系数</li>
</ul></div>
                <a href="factor_correlation_by_date.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="factor_grouping.html">factor_grouping</a></h3>
                <div><p>按日期对因子值进行分组</p>
<h1>Arguments</h1>
<ul>
<li><code>dates</code> - 日期时间戳数组</li>
<li><code>factors</code> - 因子值数组</li>
<li><code>groups_num</code> - 分组数量，默认为10</li>
</ul>
<h1>Returns</h1>
<ul>
<li>每个观测值对应的分组号(1到groups_num)</li>
</ul></div>
                <a href="factor_grouping.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_correlation_matrix.html">fast_correlation_matrix</a></h3>
                <div><p>快速计算相关性矩阵，类似于pandas的df.corr()功能。
使用并行计算和优化算法大幅提升计算性能。</p></div>
                <a href="fast_correlation_matrix.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_correlation_matrix_v2.html">fast_correlation_matrix_v2</a></h3>
                <div><p>超快速计算相关性矩阵，进一步优化版本。
采用SIMD优化和更好的内存访问模式。</p></div>
                <a href="fast_correlation_matrix_v2.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_correlation_matrix_v2_df.html">fast_correlation_matrix_v2_df</a></h3>
                <div><p>超快速计算DataFrame的相关性矩阵，进一步优化版本</p>
<p>这是rust_pyfunc.fast_correlation_matrix_v2的DataFrame封装版本，可以直接传入DataFrame
并返回保持原有列名作为索引和列名的相关性矩阵DataFrame。</p></div>
                <a href="fast_correlation_matrix_v2_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_correlation_matrix_v2_df.html">fast_correlation_matrix_v2_df</a></h3>
                <div><p>超快速计算DataFrame的相关性矩阵，进一步优化版本</p>
<p>这是rust_pyfunc.fast_correlation_matrix_v2的DataFrame封装版本，可以直接传入DataFrame
并返回保持原有列名作为索引和列名的相关性矩阵DataFrame。</p></div>
                <a href="fast_correlation_matrix_v2_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_correlation_matrix_v2_df.html">fast_correlation_matrix_v2_df</a></h3>
                <div><p>超快速计算DataFrame的相关性矩阵，进一步优化版本</p>
<p>这是rust_pyfunc.fast_correlation_matrix_v2的DataFrame封装版本，可以直接传入DataFrame
并返回保持原有列名作为索引和列名的相关性矩阵DataFrame。</p></div>
                <a href="fast_correlation_matrix_v2_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_dtw_distance.html">fast_dtw_distance</a></h3>
                <div><p>优化版DTW距离函数，使用以下技术提升性能：
1. 使用一维数组代替二维数组，减少内存分配和间接访问
2. 提前计算常用值，减少重复计算
3. 对于窗口计算进行更高效的实现
4. 优化内存访问模式，提高缓存命中率
5. 智能初始化窗口内单元格，避免无限值问题
6. 自动调整radius大小，确保计算结果有效</p>
<p>```python
import numpy as np
from rust_pyfunc import fast_dtw_distance, dtw_distance</p>
<h1>创建两个时间序列</h1>
<p>s1 = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
s2 = np.array([1.1, 2.1, 3.1, 4.1, 5.1])</p>
<h1>比较两种实现的结果和性能</h1>
<p>import time</p>
<p>start = time.time()
result1 = dtw_distance(s1, s2)
time1 = time.time() - start</p>
<p>start = time.time()
result2 = fast_dtw_distance(s1, s2)
time2 = time.time() - start</p>
<p>print(f"标准DTW距离: {result1:.6f}, 耗时: {time1:.6f}秒")
print(f"快速DTW距离: {result2:.6f}, 耗时: {time2:.6f}秒")
print(f"加速比: {time1/time2:.2f}倍")
```</p></div>
                <a href="fast_dtw_distance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_find_half_extreme_time.html">fast_find_half_extreme_time</a></h3>
                <div><p>计算半极端时间的优化版本</p>
<p>该函数针对find_half_extreme_time进行了多项优化：
1. 预计算和缓存 - 避免重复计算时间差和比率
2. 数据布局优化 - 改进内存访问模式
3. 条件分支优化 - 减少分支预测失败
4. 界限优化 - 提前确定搜索范围</p></div>
                <a href="fast_find_half_extreme_time.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_inner_join_dataframes.html">fast_inner_join_dataframes</a></h3>
                <div><p>高性能DataFrame内连接，专门优化Python DataFrame处理</p></div>
                <a href="fast_inner_join_dataframes.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_inner_join_df.html">fast_inner_join_df</a></h3>
                <div><p>快速内连接的便捷函数</p></div>
                <a href="fast_inner_join_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_left_join_df.html">fast_left_join_df</a></h3>
                <div><p>快速左连接的便捷函数</p></div>
                <a href="fast_left_join_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_merge.html">fast_merge</a></h3>
                <div><p>高性能merge函数，支持数据表连接操作</p></div>
                <a href="fast_merge.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_merge_df.html">fast_merge_df</a></h3>
                <div><p>高性能的DataFrame merge函数</p>
<p>这是rust_pyfunc.fast_merge的DataFrame封装版本，可以直接传入DataFrame
并返回标准的DataFrame结果。</p></div>
                <a href="fast_merge_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_merge_df.html">fast_merge_df</a></h3>
                <div><p>高性能的DataFrame merge函数</p>
<p>这是rust_pyfunc.fast_merge的DataFrame封装版本，可以直接传入DataFrame
并返回标准的DataFrame结果。</p></div>
                <a href="fast_merge_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_merge_df.html">fast_merge_df</a></h3>
                <div><p>高性能的DataFrame merge函数</p>
<p>这是rust_pyfunc.fast_merge的DataFrame封装版本，可以直接传入DataFrame
并返回标准的DataFrame结果。</p></div>
                <a href="fast_merge_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_merge_mixed.html">fast_merge_mixed</a></h3>
                <div><p>高性能merge函数，支持字符串和数值类型的连接键</p></div>
                <a href="fast_merge_mixed.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_outer_join_df.html">fast_outer_join_df</a></h3>
                <div><p>快速外连接的便捷函数</p></div>
                <a href="fast_outer_join_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_right_join_df.html">fast_right_join_df</a></h3>
                <div><p>快速右连接的便捷函数</p></div>
                <a href="fast_right_join_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fit_hawkes_process.html">fit_hawkes_process</a></h3>
                <div><p>拟合Hawkes自激点过程模型并计算多种指标</p>
<p>该函数使用指数核函数 φ(u) = α * exp(-β * u) 拟合Hawkes过程,
计算模型参数和各种金融指标,用于分析逐笔成交数据的自激特性。</p>
<h2>参数</h2>
<p>event_times : numpy.ndarray
    事件时间戳数组(单位:秒),需要是升序排列
event_volumes : numpy.ndarray
    事件对应的成交量数组
initial_guess : Optional[Tuple[float, float, float]], optional
    参数初始猜测值 (mu, alpha, beta)
    - mu: 外生事件强度(基准强度)
    - alpha: 自激强度系数
    - beta: 核函数衰减率
    默认为None,使用启发式方法自动初始化
max_iterations : int, optional
    EM算法最大迭代次数,默认为1000
tolerance : float, optional
    收敛容差,默认为1e-6
cluster_merge_threshold : float, optional
    簇合并阈值(0-1),控制事件并入已有簇的宽松程度;
    数值越大越容易把事件并入已有簇,形成更大的簇;
    数值越小越严格,更倾向于创建新簇
    默认0.8,建议范围[0.5, 0.95]</p>
<pre><code>示例:
- threshold=0.3: 严格,只合并概率明显更高的事件,产生更多小簇
- threshold=0.8: 宽松,容易合并事件,允许产生大簇
</code></pre>
<h2>返回值</h2>
<p>dict
    包含以下字段的字典:
    - 'mu': 外生事件强度估计值
    - 'alpha': 自激强度系数估计值
    - 'beta': 核函数衰减率估计值
    - 'branching_ratio': 分枝率 n = α/β
    - 'mean_intensity': 无条件平均强度 Λ = μ/(1-n)
    - 'exogenous_intensity': 外生强度 = μ
    - 'endogenous_intensity': 内生强度 = Λ - μ
    - 'expected_cluster_size': 期望簇大小 = 1/(1-n)
    - 'half_life': 半衰期 = ln(2)/β
    - 'mean_parent_child_interval': 父子平均间隔 = 1/β
    - 'log_likelihood': 对数似然值
    - 'event_intensities': 每个事件时刻的强度值
    - 'root_probabilities': 每个事件是根节点(外生事件)的概率
    - 'expected_children': 每个事件的预期子女数
    - 'cluster_assignments': 每个事件所属的簇ID
    - 'cluster_sizes': 每个簇的大小
    - 'cluster_durations': 每个簇的持续时间
    - 'cluster_volumes': 每个簇的成交量总和</p>
<h2>示例</h2>
<blockquote>
<blockquote>
<blockquote>
<p>import rust_pyfunc as rp
import numpy as np</p>
<h1>模拟逐笔成交数据</h1>
<p>times = np.cumsum(np.random.exponential(0.1, 1000))
volumes = np.random.lognormal(10, 1, 1000)
result = rp.fit_hawkes_process(times, volumes)
print(f"分枝率: {result['branching_ratio']:.3f}")
print(f"期望簇大小: {result['expected_cluster_size']:.2f}")
print(f"平均强度: {result['mean_intensity']:.3f}")</p>
</blockquote>
</blockquote>
</blockquote></div>
                <a href="fit_hawkes_process.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="gp_correlation_dimension.html">gp_correlation_dimension</a></h3>
                <div><p>可选参数入口：可提供自定义选项</p></div>
                <a href="gp_correlation_dimension.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="gp_correlation_dimension_auto.html">gp_correlation_dimension_auto</a></h3>
                <div><p>零参数入口：只需传入序列，所有参数自动确定</p></div>
                <a href="gp_correlation_dimension_auto.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="gp_create_default_options.html">gp_create_default_options</a></h3>
                <div><p>为 Python 导出的辅助函数</p></div>
                <a href="gp_create_default_options.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="gp_create_options.html">gp_create_options</a></h3>
                <div><p>无文档</p></div>
                <a href="gp_create_options.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="hawkes_event_indicators.html">hawkes_event_indicators</a></h3>
                <div><p>计算Hawkes过程的事件级指标（需要价格数据）</p>
<p>该函数在fit_hawkes_process的基础上,增加了需要价格数据的指标计算。
额外计算的指标主要用于分析每个事件对价格的影响。</p>
<h2>参数</h2>
<p>event_times : numpy.ndarray
    事件时间戳数组(单位:秒),需要是升序排列
event_volumes : numpy.ndarray
    事件对应的成交量数组
event_prices : numpy.ndarray
    事件对应的价格数组
initial_guess : Optional[Tuple[float, float, float]], optional
    参数初始猜测值 (mu, alpha, beta),默认为None
max_iterations : int, optional
    EM算法最大迭代次数,默认为1000
tolerance : float, optional
    收敛容差,默认为1e-6
cluster_merge_threshold : float, optional
    簇合并阈值(0-1),控制事件并入已有簇的宽松程度;
    数值越大越容易把事件并入已有簇,形成更大的簇;
    数值越小越严格,更倾向于创建新簇
    默认0.8,建议范围[0.5, 0.95]</p>
<h2>返回值</h2>
<p>dict
    包含fit_hawkes_process的所有字段,以及：
    - 'cluster_price_changes': 每个簇的价格变化(簇结束时价格 - 簇开始时价格)
    - 'time_intervals': 连续事件间的时间间隔</p>
<h2>新指标解释</h2>
<ol>
<li>
<p>簇价格变化(cluster_price_changes): 每个成交簇从开始到结束的价格变化,
   反映该簇交易活动对价格的影响方向和幅度。</p>
</li>
<li>
<p>时间间隔(time_intervals): 连续成交事件之间的时间间隔,
   可用于分析市场活跃度的时间模式。</p>
</li>
</ol>
<h2>示例</h2>
<blockquote>
<blockquote>
<blockquote>
<p>import rust_pyfunc as rp
import numpy as np</p>
<h1>读取真实逐笔成交数据</h1>
<p>df = read_trade_data('000001', 20220101)
df['time_seconds'] = (df.exchtime - df.exchtime.min()).dt.total_seconds()
result = rp.hawkes_event_indicators(
...     df.time_seconds.to_numpy(),
...     df.volume.to_numpy(),
...     df.price.to_numpy()
... )</p>
<h1>分析大簇的价格影响</h1>
<p>large_clusters = np.array(result['cluster_sizes']) &gt; 10
price_changes = np.array(result['cluster_price_changes'])[large_clusters]
print(f"大簇平均价格变化: {np.mean(price_changes):.4f}")</p>
</blockquote>
</blockquote>
</blockquote></div>
                <a href="hawkes_event_indicators.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="hmm_trend_prediction.html">hmm_trend_prediction</a></h3>
                <div><p>主要的HMM趋势预测函数</p></div>
                <a href="hmm_trend_prediction.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="local_correlation.html">local_correlation</a></h3>
                <div><p>计算价格序列的局部相关性分析</p>
<p>对于每个价格点，向前取x个值作为局部序列，然后分别向前和向后搜索，
找到与当前局部序列相关性最大和最小的位置，并计算间隔行数和volume总和。</p></div>
                <a href="local_correlation.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="lz_complexity.html">lz_complexity</a></h3>
                <div><p>LZ76增量分解复杂度计算</p>
<p>参数:
- seq: 输入序列，可以是1D numpy数组
- quantiles: 分位数列表，用于连续变量离散化，None表示序列已经是离散的
- normalize: 是否归一化结果</p>
<p>返回:
- LZ复杂度值</p></div>
                <a href="lz_complexity.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="lz_complexity_detailed.html">lz_complexity_detailed</a></h3>
                <div><p>LZ76增量分解复杂度详细分析计算</p>
<p>参数:
- seq: 输入序列，可以是1D numpy数组
- quantiles: 分位数列表，用于连续变量离散化，None表示序列已经是离散的
- normalize: 是否归一化结果</p>
<p>返回:
- 包含详细统计信息的字典</p></div>
                <a href="lz_complexity_detailed.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="mark_follow_groups.html">mark_follow_groups</a></h3>
                <div><p>标记每一行在其后0.1秒内具有相同price和volume的行组。
对于同一个时间窗口内的相同交易组，标记相同的组号。
组号从1开始递增，每遇到一个新的交易组就分配一个新的组号。</p></div>
                <a href="mark_follow_groups.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="mark_follow_groups_with_flag.html">mark_follow_groups_with_flag</a></h3>
                <div><p>标记每一行在其后time_window秒内具有相同flag、price和volume的行组。
对于同一个时间窗口内的相同交易组，标记相同的组号。
组号从1开始递增，每遇到一个新的交易组就分配一个新的组号。</p></div>
                <a href="mark_follow_groups_with_flag.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="matrix_eigenvalue_analysis.html">matrix_eigenvalue_analysis</a></h3>
                <div><p>计算多列数据的差值矩阵特征值</p>
<p>对输入的237行×n列矩阵，对每一列进行以下操作：
1. 构建237×237的差值矩阵，其中M[i,j] = col[i] - col[j]
2. 计算该矩阵的所有特征值
3. 按特征值绝对值从大到小排序</p>
<p>此函数针对高性能计算进行了优化：
- 使用并行处理处理不同列（最多10个核心）
- 利用差值矩阵的对称性质优化计算
- 使用高效的线性代数库nalgebra进行特征值分解</p></div>
                <a href="matrix_eigenvalue_analysis.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="matrix_eigenvalue_analysis_modified.html">matrix_eigenvalue_analysis_modified</a></h3>
                <div><p>计算多列数据的修改差值矩阵特征值（高性能版本）</p>
<p>对输入的m行×n列矩阵，对每一列进行以下操作：
1. 构建m×m的修改差值矩阵：
   - 上三角: M[i,j] = col[i] - col[j] (i &lt; j)
   - 对角线: M[i,i] = 0
   - 下三角: M[i,j] = |col[i] - col[j]| (i &gt; j)
2. 计算该矩阵的所有特征值
3. 按特征值绝对值从大到小排序</p>
<p>优化策略：
- 高度并行化（最多10个核心）
- 内存预分配和重用
- SIMD优化的矩阵运算
- 缓存友好的数据访问模式</p></div>
                <a href="matrix_eigenvalue_analysis_modified.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="matrix_eigenvalue_analysis_modified_ultra.html">matrix_eigenvalue_analysis_modified_ultra</a></h3>
                <div><p>计算多列数据的修改差值矩阵特征值（超级优化版本）</p>
<p>这个版本包含了所有可能的性能优化：
- 预分配内存池
- 批量处理
- 缓存优化的数据结构
- 更高效的特征值算法
- 1秒超时机制，防止卡死</p></div>
                <a href="matrix_eigenvalue_analysis_modified_ultra.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="matrix_eigenvalue_analysis_optimized.html">matrix_eigenvalue_analysis_optimized</a></h3>
                <div><p>计算多列数据的差值矩阵特征值（优化版本）</p>
<p>这是一个针对大规模计算优化的版本，使用了更高效的算法：
1. 利用差值矩阵的反对称性质减少计算量
2. 使用更高效的内存布局
3. 优化的并行策略</p></div>
                <a href="matrix_eigenvalue_analysis_optimized.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="max_range_loop.html">max_range_loop</a></h3>
                <div><p>计算序列中每个位置结尾的最长连续子序列长度，其中子序列的最大值在该位置。</p></div>
                <a href="max_range_loop.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="min_range_loop.html">min_range_loop</a></h3>
                <div><p>计算序列中每个位置结尾的最长连续子序列长度，其中子序列的最小值在该位置。</p></div>
                <a href="min_range_loop.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="mutual_information_2d_knn.html">mutual_information_2d_knn</a></h3>
                <div><p>Calculate mutual information for corresponding rows of two 2D arrays
using KSG (Kraskov-Stögbauer-Grassberger) method 1 with consistent Euclidean distance.
Both joint and marginal neighbor counting use the same Euclidean distance metric.</p></div>
                <a href="mutual_information_2d_knn.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="mutual_information_2d_knn_chebyshev.html">mutual_information_2d_knn_chebyshev</a></h3>
                <div><p>Calculate mutual information for corresponding rows using Chebyshev distance</p></div>
                <a href="mutual_information_2d_knn_chebyshev.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="mutual_information_2d_knn_final.html">mutual_information_2d_knn_final</a></h3>
                <div><p>Calculate mutual information for corresponding rows of two 2D arrays
using corrected KSG method with negative value truncation.</p>
<p>此函数是mutual_information_2d_knn的最终修复版本，解决了负数互信息的问题。</p>
<p>修复原理：
KSG估计器在弱相关情况下可能产生负值估计，这是已知的有限样本偏差现象。
根据信息论理论，互信息I(X;Y) ≥ 0永远成立，因此我们将负值截断为0。
这是处理KSG估计器负值问题的标准做法。</p>
<p>算法特点：
- 使用KSG方法1进行互信息估计
- 采用Chebyshev距离确定k近邻
- 实施负值截断确保理论一致性
- 保持高性能的Rust实现</p></div>
                <a href="mutual_information_2d_knn_final.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="mutual_information_2d_knn_fixed.html">mutual_information_2d_knn_fixed</a></h3>
                <div><p>Calculate mutual information for corresponding rows of two 2D arrays
using corrected KSG (Kraskov-Stögbauer-Grassberger) method.
This fixes the negative values issue by using proper 1D counting.</p></div>
                <a href="mutual_information_2d_knn_fixed.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="mutual_information_knn.html">mutual_information_knn</a></h3>
                <div><p>Calculate mutual information using KSG (Kraskov-Stögbauer-Grassberger) method 1
Uses Euclidean distance for k-nearest neighbor search</p></div>
                <a href="mutual_information_knn.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="mutual_information_knn_chebyshev.html">mutual_information_knn_chebyshev</a></h3>
                <div><p>Calculate mutual information using KSG method 2 (Chebyshev distance)</p></div>
                <a href="mutual_information_knn_chebyshev.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="ols.html">ols</a></h3>
                <div><p>普通最小二乘(OLS)回归。
用于拟合线性回归模型 y = Xβ + ε，其中β是要估计的回归系数。</p></div>
                <a href="ols.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="ols_predict.html">ols_predict</a></h3>
                <div><p>使用已有数据和响应变量，对新的数据点进行OLS线性回归预测。</p></div>
                <a href="ols_predict.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="ols_residuals.html">ols_residuals</a></h3>
                <div><p>计算普通最小二乘(OLS)回归的残差序列。
残差表示实际观测值与模型预测值之间的差异: ε = y - Xβ。</p></div>
                <a href="ols_residuals.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="order_contamination.html">order_contamination</a></h3>
                <div><p>优化版订单浸染函数 - 高性能单线程版本</p>
<h1>参数</h1>
<ul>
<li>exchtime: 成交时间数组（纳秒）</li>
<li>order: 订单编号数组</li>
<li>volume: 成交量数组  </li>
<li>top_percentile: 大单百分比阈值 (1-100)，表示前x%，默认10表示前10%</li>
<li>time_window_seconds: 时间窗口（秒），默认1秒</li>
</ul>
<h1>返回</h1>
<p>浸染后的订单编号数组</p></div>
                <a href="order_contamination.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="order_contamination_bilateral.html">order_contamination_bilateral</a></h3>
                <div><p>双边订单浸染函数 - 分别处理买单和卖单的浸染</p>
<h1>参数</h1>
<ul>
<li>exchtime: 成交时间数组（纳秒）</li>
<li>bid_order: 买单编号数组</li>
<li>ask_order: 卖单编号数组  </li>
<li>volume: 成交量数组</li>
<li>top_percentile: 大单百分比阈值 (1-100)，表示前x%，默认10表示前10%</li>
<li>time_window_seconds: 时间窗口（秒），默认1秒</li>
</ul>
<h1>返回</h1>
<p>(浸染后的买单编号数组, 浸染后的卖单编号数组)</p></div>
                <a href="order_contamination_bilateral.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="order_contamination_parallel.html">order_contamination_parallel</a></h3>
                <div><p>并行版本的订单浸染函数（使用5核心，适用于大数据量）</p></div>
                <a href="order_contamination_parallel.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="order_neighborhood_analysis.html">order_neighborhood_analysis</a></h3>
                <div><p>超级高速订单邻域分析函数 - 为13万数据优化</p>
<p>激进优化策略：
1. 预计算邻域索引表
2. 批量SIMD计算
3. 内存预分配避免动态分配
4. 分层并行处理
5. 零拷贝数据传递</p></div>
                <a href="order_neighborhood_analysis.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="pandas_series_rank.html">pandas_series_rank</a></h3>
                <div><p>计算pandas Series的排名 (单线程版本)</p>
<h1>Arguments</h1>
<ul>
<li><code>data</code> - 输入的一维数组数据</li>
<li><code>method</code> - 排名方法: "average", "min", "max", "first", "dense"</li>
<li><code>ascending</code> - 是否升序排列</li>
<li><code>na_option</code> - NaN处理方式: "keep", "top", "bottom"</li>
</ul>
<h1>Returns</h1>
<ul>
<li>排名结果的一维数组</li>
</ul></div>
                <a href="pandas_series_rank.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="price_volume_orderbook_correlation.html">price_volume_orderbook_correlation</a></h3>
                <div><p>无文档</p></div>
                <a href="price_volume_orderbook_correlation.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup.html">query_backup</a></h3>
                <div><p>无文档</p></div>
                <a href="query_backup.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_columns_range_with_filter.html">query_backup_columns_range_with_filter</a></h3>
                <div><p>查询备份文件中的指定列范围，支持过滤</p>
<p>参数:
- backup_file: 备份文件路径
- column_start: 开始列索引（包含）
- column_end: 结束列索引（包含）
- dates: 可选的日期过滤列表
- codes: 可选的代码过滤列表</p>
<p>返回:
包含numpy数组的字典: {"date": 日期数组, "code": 代码数组, "factors": 指定列范围的因子值数组}</p></div>
                <a href="query_backup_columns_range_with_filter.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_factor_only.html">query_backup_factor_only</a></h3>
                <div><p>查询备份文件中的指定列因子值（纯因子值数组）</p>
<p>参数:
- backup_file: 备份文件路径
- column_index: 要读取的因子列索引（0表示第一列因子值）</p>
<p>返回:
只包含因子值的numpy数组</p></div>
                <a href="query_backup_factor_only.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_factor_only_ultra_fast.html">query_backup_factor_only_ultra_fast</a></h3>
                <div><p>超高速查询备份文件中的指定列因子值</p>
<p>参数:
- backup_file: 备份文件路径
- column_index: 要读取的因子列索引（0表示第一列因子值）</p>
<p>返回:
只包含因子值的numpy数组</p></div>
                <a href="query_backup_factor_only_ultra_fast.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_factor_only_with_filter.html">query_backup_factor_only_with_filter</a></h3>
                <div><p>查询备份文件中的指定列因子值（纯因子值数组），支持过滤</p>
<p>参数:
- backup_file: 备份文件路径
- column_index: 要读取的因子列索引（0表示第一列因子值）
- dates: 可选的日期过滤列表
- codes: 可选的代码过滤列表</p>
<p>返回:
只包含因子值的numpy数组</p></div>
                <a href="query_backup_factor_only_with_filter.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_fast.html">query_backup_fast</a></h3>
                <div><p>高速并行备份查询函数，专门优化大文件读取</p></div>
                <a href="query_backup_fast.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_single_column.html">query_backup_single_column</a></h3>
                <div><p>查询备份文件中的指定列</p>
<p>参数:
- backup_file: 备份文件路径
- column_index: 要读取的因子列索引（0表示第一列因子值）
- use_single_thread: 是否使用单线程读取</p>
<p>返回:
包含三个numpy数组的字典: {"date": 日期数组, "code": 代码数组, "factor": 指定列的因子值数组}</p></div>
                <a href="query_backup_single_column.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_single_column_with_filter.html">query_backup_single_column_with_filter</a></h3>
                <div><p>查询备份文件中的指定列，支持过滤</p>
<p>参数:
- backup_file: 备份文件路径
- column_index: 要读取的因子列索引（0表示第一列因子值）
- dates: 可选的日期过滤列表
- codes: 可选的代码过滤列表</p>
<p>返回:
包含三个numpy数组的字典: {"date": 日期数组, "code": 代码数组, "factor": 指定列的因子值数组}</p></div>
                <a href="query_backup_single_column_with_filter.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rank_axis0_df.html">rank_axis0_df</a></h3>
                <div><p>高性能的DataFrame rank函数，支持axis=0（沿列方向排名）</p>
<p>通过转置实现沿列方向的排名，同样具有高性能优势。</p></div>
                <a href="rank_axis0_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rank_axis0_df.html">rank_axis0_df</a></h3>
                <div><p>高性能的DataFrame rank函数，支持axis=0（沿列方向排名）</p>
<p>通过转置实现沿列方向的排名，同样具有高性能优势。</p></div>
                <a href="rank_axis0_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rank_axis1.html">rank_axis1</a></h3>
                <div><p>高性能的DataFrame rank函数，支持axis=1（沿行方向排名）
相比pandas的rank函数能显著提升性能</p></div>
                <a href="rank_axis1.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rank_axis1_df.html">rank_axis1_df</a></h3>
                <div><p>高性能的DataFrame rank函数，支持axis=1（沿行方向排名）</p>
<p>这是rust_pyfunc.rank_axis1的DataFrame封装版本，可以直接传入DataFrame
并返回保持原有索引和列名的DataFrame结果。</p></div>
                <a href="rank_axis1_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rank_axis1_df.html">rank_axis1_df</a></h3>
                <div><p>高性能的DataFrame rank函数，支持axis=1（沿行方向排名）</p>
<p>这是rust_pyfunc.rank_axis1的DataFrame封装版本，可以直接传入DataFrame
并返回保持原有索引和列名的DataFrame结果。</p></div>
                <a href="rank_axis1_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rank_axis1_df.html">rank_axis1_df</a></h3>
                <div><p>高性能的DataFrame rank函数，支持axis=1（沿行方向排名）</p>
<p>这是rust_pyfunc.rank_axis1的DataFrame封装版本，可以直接传入DataFrame
并返回保持原有索引和列名的DataFrame结果。</p></div>
                <a href="rank_axis1_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="reconstruct_limit_order_lifecycle.html">reconstruct_limit_order_lifecycle</a></h3>
                <div><p>无文档</p></div>
                <a href="reconstruct_limit_order_lifecycle.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="reconstruct_limit_order_lifecycle_v2.html">reconstruct_limit_order_lifecycle_v2</a></h3>
                <div><p>限价单生命周期重建 v2</p>
<p>功能：通过匹配高频逐笔成交数据与盘口快照数据，使用订单ID作为追踪器，
重建限价单生命周期指标</p>
<p>输入：
- ticks_array: 逐笔成交数据 (N_ticks x 7)
  - 列0: exchtime (时间戳)
  - 列1: price (成交价格)
  - 列2: volume (成交量)
  - 列3: turnover (成交金额)
  - 列4: flag (交易标志: 66=主买, 83=主卖, 32=撤单)
  - 列5: ask_order (卖单订单ID)
  - 列6: bid_order (买单订单ID)</p>
<ul>
<li>snaps_array: 盘口快照数据 (N_snaps x 41+)</li>
<li>列0: exchtime (时间戳)</li>
<li>列1-10: bid_prc1-10 (买价1-10档)</li>
<li>列11-20: bid_vol1-10 (买量1-10档)</li>
<li>列21-30: ask_prc1-10 (卖价1-10档)</li>
<li>列31-40: ask_vol1-10 (卖量1-10档)</li>
</ul>
<p>输出：
- features_array: 特征数组 (N_snaps * 20 x 15)
  - 每行代表一个(快照, 档位, 方向)组合
  - 列0: timestamp (时间戳)
  - 列1: side_flag (0=Bid, 1=Ask)
  - 列2: level_index (1-10档)
  - 列3: vol_sum (成交量总和)
  - 列4: vol_mean (成交量均值)
  - 列5: vol_std (成交量标准差)
  - 列6: vol_skew (成交量偏度)
  - 列7: vol_autocorr (成交量滞后1阶自相关)
  - 列8: vol_trend (成交量趋势相关性)
  - 列9: id_count (匹配订单数)
  - 列10: id_span (订单ID跨度)
  - 列11: id_mean_diff (订单ID差值均值)
  - 列12: id_std_diff (订单ID差值标准差)
  - 列13: id_skew_diff (订单ID差值偏度)
  - 列14: id_trend (订单ID趋势相关性)</p></div>
                <a href="reconstruct_limit_order_lifecycle_v2.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_correlation_mean.html">rolling_correlation_mean</a></h3>
                <div><p>滚动窗口计算相关性矩阵均值</p>
<p>对于输入数据的每一行，计算其过去window_size行的相关性矩阵，
然后计算该相关性矩阵中所有值的均值。</p></div>
                <a href="rolling_correlation_mean.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_correlation_skew.html">rolling_correlation_skew</a></h3>
                <div><p>滚动窗口计算相关性矩阵偏度</p>
<p>对于输入数据的每一行，计算其过去window_size行的相关性矩阵，
然后计算该相关性矩阵中所有值的偏度（skewness）。
偏度衡量相关性分布的不对称性：
- 偏度 &gt; 0：右偏（正偏），大部分相关性值较小，少数值较大
- 偏度 &lt; 0：左偏（负偏），大部分相关性值较大，少数值较小
- 偏度 ≈ 0：接近对称分布</p></div>
                <a href="rolling_correlation_skew.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_cv.html">rolling_cv</a></h3>
                <div><p>计算价格序列的滚动变异系数(CV)。</p>
<p>对于位置i，从数据范围[i-lookback+1, i]中每隔interval个点取样，
然后计算相邻样本之间的对数收益率（后面的价格除以前面的价格的对数），
最后计算这些收益率的变异系数（标准差除以均值）。</p></div>
                <a href="rolling_cv.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_dtw_distance.html">rolling_dtw_distance</a></h3>
                <div><p>计算每个大单与其临近小单之间的时间间隔均值。</p></div>
                <a href="rolling_dtw_distance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_effective_memory_length.html">rolling_effective_memory_length</a></h3>
                <div><p>批量计算有效记忆长度 (滚动窗口) - 带步长优化的版本</p>
<h1>性能优化技术</h1>
<ol>
<li>支持步长参数，减少计算量</li>
<li>全局离散化，避免重复计算</li>
<li>lag=1特殊优化路径</li>
</ol>
<h1>步长说明</h1>
<p>step=1: 计算每个窗口（最精确，但最慢）
step=10: 每隔10个点计算一次（速度提升10倍）</p>
<h1>分位数说明</h1>
<p>quantile=0.5: 中位数分割 (默认)
quantile=0.9: 90%分位数分割，只有前10%最高成交量为1</p></div>
                <a href="rolling_effective_memory_length.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_information_gain.html">rolling_information_gain</a></h3>
                <div><p>计算信息增益序列 - 返回每个lag的信息增益</p>
<h1>参数</h1>
<ul>
<li><code>data</code> - 成交量或其他一维数据序列 (numpy array)</li>
<li><code>window_size</code> - 统计窗口大小</li>
<li><code>max_lag</code> - 最大回顾长度</li>
<li><code>quantile</code> - 离散化分位数, 默认0.5 (中位数)</li>
</ul>
<h1>返回</h1>
<ul>
<li>二维数组，每一行是一个时间点，每一列是对应lag的信息增益</li>
</ul>
<h1>返回值说明</h1>
<p>返回形状为 (n, max_lag) 的二维数组：
- 每一行对应一个时间点
- 每一列对应一个lag（lag=1在第一列，lag=max_lag在最后一列）
- 前 window_size + max_lag 行全为0（数据不足）</p></div>
                <a href="rolling_information_gain.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_information_gain_fast.html">rolling_information_gain_fast</a></h3>
                <div><p>滚动窗口计算信息增益序列（高性能优化版本）</p>
<h1>性能优化</h1>
<ul>
<li>批量计算所有lag的条件熵，避免重复遍历</li>
<li>使用固定数组替代HashMap</li>
<li>预期性能提升：10-30倍</li>
</ul>
<h1>参数</h1>
<ul>
<li><code>data</code> - 成交量或其他一维数据序列</li>
<li><code>window_size</code> - 统计窗口大小</li>
<li><code>max_lag</code> - 最大回顾长度</li>
<li><code>quantile</code> - 离散化分位数，默认0.5</li>
<li><code>step</code> - 计算步长，默认1</li>
</ul>
<h1>返回</h1>
<ul>
<li>扁平化的二维数组，形状为 (n, max_lag)</li>
</ul></div>
                <a href="rolling_information_gain_fast.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_lagged_regression.html">rolling_lagged_regression</a></h3>
                <div><p>滞后自回归分析函数</p>
<p>参数:
- series: 一维时间序列数据
- past_periods: 过去观察期数
- future_periods: 预测期数，必须 &lt;= past_periods</p>
<p>返回:
- 二维数组 (n, 2*x)，其中 x = past_periods - future_periods + 1
- 每行包含 [r_lag1_past, r_lag2_past, ..., r_lagx_past, r_lag1_future, r_lag2_future, ..., r_lagx_future]</p></div>
                <a href="rolling_lagged_regression.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_lagged_regression_ridge.html">rolling_lagged_regression_ridge</a></h3>
                <div><p>Ridge回归版本的滞后自回归分析函数</p>
<p>参数:
- series: 一维时间序列数据
- past_periods: 过去观察期数
- future_periods: 预测期数，必须 &lt;= past_periods
- alpha: Ridge正则化参数，默认使用自适应选择</p>
<p>返回:
- 二维数组 (n, 2*x)，其中 x = past_periods - future_periods + 1
- 每行包含 [r_lag1_past, r_lag2_past, ..., r_lagx_past, r_lag1_future, r_lag2_future, ..., r_lagx_future]</p></div>
                <a href="rolling_lagged_regression_ridge.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_lagged_regression_ridge_fast.html">rolling_lagged_regression_ridge_fast</a></h3>
                <div><p>高性能Ridge回归版本的滞后自回归分析函数</p>
<p>参数:
- series: 一维时间序列数据
- past_periods: 过去观察期数
- future_periods: 预测期数，必须 &lt;= past_periods
- alpha: Ridge正则化参数，默认使用自适应选择</p>
<p>返回:
- 二维数组 (n, 2*x)，其中 x = past_periods - future_periods + 1
- 每行包含 [r_lag1_past, r_lag2_past, ..., r_lagx_past, r_lag1_future, r_lag2_future, ..., r_lagx_future]</p>
<p>优化特性:
- 使用faer库实现5-17倍矩阵运算性能提升
- 内存池和缓冲区重用减少分配开销
- alpha参数缓存机制减少重复计算</p></div>
                <a href="rolling_lagged_regression_ridge_fast.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_lagged_regression_ridge_incremental.html">rolling_lagged_regression_ridge_incremental</a></h3>
                <div><p>增量更新版本的滞后自回归分析</p>
<p>核心优化：
1. 维护X'X和X'y矩阵的增量更新，避免重复计算
2. 利用滑动窗口的重叠特性，每次只计算差量
3. 预期性能提升30-40%</p></div>
                <a href="rolling_lagged_regression_ridge_incremental.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_lagged_regression_ridge_simd.html">rolling_lagged_regression_ridge_simd</a></h3>
                <div><p>SIMD优化版本的主函数</p></div>
                <a href="rolling_lagged_regression_ridge_simd.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_qcv.html">rolling_qcv</a></h3>
                <div><p>计算价格序列的滚动四分位变异系数(QCV)。</p>
<p>对于位置i，从数据范围[i-lookback+1, i]中每隔interval个点取样，
然后计算相邻样本之间的对数收益率（后面的价格除以前面的价格的对数），
最后计算这些收益率的四分位变异系数（四分位间距除以中位数的绝对值）。
这种方法对异常值和均值接近零的情况更加稳健。</p></div>
                <a href="rolling_qcv.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_volatility.html">rolling_volatility</a></h3>
                <div><p>计算价格序列的滚动波动率。</p>
<p>对于位置i，从数据范围[i-lookback+1, i]中每隔interval个点取样，
然后计算相邻样本之间的对数收益率（后面的价格除以前面的价格的对数），
最后计算这些收益率的标准差作为波动率。</p></div>
                <a href="rolling_volatility.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_window_core_feature.html">rolling_window_core_feature</a></h3>
                <div><p>滚动窗口核心特征提取</p>
<p>对输入序列进行滚动窗口分析，识别每个窗口中最重要的特征位置（核心特征）
和最不重要的特征位置。通过计算窗口间的相关性并分析mask效应来确定特征重要性。</p>
<p>算法原理：
1. 对每个滚动窗口，计算其与所有其他窗口的相关系数（基准相关性）
2. 依次将窗口内每个位置设为NaN，重新计算相关系数
3. 相关性变化最小的位置为最重要特征（核心代表性）
4. 相关性变化最大的位置为最不重要特征</p></div>
                <a href="rolling_window_core_feature.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_window_core_feature_optimized.html">rolling_window_core_feature_optimized</a></h3>
                <div><p>优化版滚动窗口核心特征提取</p>
<p>针对性能优化的版本，使用以下优化策略：
1. 增量相关性计算：避免重复计算统计量
2. 预计算缓存：缓存窗口间的相关性矩阵
3. 内存优化：重用缓冲区，减少内存分配
4. 向量化操作：使用SIMD友好的计算模式</p></div>
                <a href="rolling_window_core_feature_optimized.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_window_core_feature_simd.html">rolling_window_core_feature_simd</a></h3>
                <div><p>SIMD优化版滚动窗口核心特征提取</p>
<p>使用显式SIMD指令和智能缓存策略优化性能：
1. SIMD向量化统计量计算
2. LRU缓存避免重复相关性计算
3. 批量内存访问优化
4. 数值计算热点优化</p></div>
                <a href="rolling_window_core_feature_simd.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_window_core_feature_ultra.html">rolling_window_core_feature_ultra</a></h3>
                <div><p>超级轻量级优化版滚动窗口核心特征提取</p>
<p>基于性能测试结果，专注于最有效的优化：
1. 极致的内联优化
2. 最小化内存分配
3. CPU缓存友好的数据访问模式
4. 编译器友好的代码结构</p>
<p>去掉所有复杂缓存机制，专注于算法核心优化</p></div>
                <a href="rolling_window_core_feature_ultra.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_window_stat.html">rolling_window_stat</a></h3>
                <div><p>计算时间序列在指定时间窗口内向后滚动的统计量。
对于每个时间点，计算该点之后指定时间窗口内所有数据的指定统计量。</p></div>
                <a href="rolling_window_stat.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_window_stat_backward.html">rolling_window_stat_backward</a></h3>
                <div><p>计算时间序列在指定时间窗口内向前滚动的统计量。
对于每个时间点，计算该点之前指定时间窗口内所有数据的指定统计量。</p></div>
                <a href="rolling_window_stat_backward.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="run_pools_queue.html">run_pools_queue</a></h3>
                <div><p>无文档</p></div>
                <a href="run_pools_queue.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="run_pools_simple.html">run_pools_simple</a></h3>
                <div><p>极简版并行计算函数 - 只执行不返回</p></div>
                <a href="run_pools_simple.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="segment_and_correlate.html">segment_and_correlate</a></h3>
                <div><p>序列分段和相关系数计算函数</p>
<p>输入两个等长的序列，根据大小关系进行分段，然后计算每段内的相关系数</p></div>
                <a href="segment_and_correlate.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="skew_numba.html">skew_numba</a></h3>
                <div><p>计算3D数组各(i,j)位置的偏态值</p>
<p>输入: shape (n, n, r*r) 的3D数组
输出: shape (n, n) 的2D偏态值矩阵</p>
<p>偏态公式: skew = E[(X-μ)³] / σ³</p></div>
                <a href="skew_numba.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="sum_as_string.html">sum_as_string</a></h3>
                <div><p>Formats the sum of two numbers as string.</p></div>
                <a href="sum_as_string.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="super_dtw_distance.html">super_dtw_distance</a></h3>
                <div><p>超级优化版DTW距离函数，使用以下高级技术提升性能：
1. 内存预分配 - 减少运行时内存分配
2. 更精细的内存访问优化 - 提高缓存命中率
3. 基于启发式的跳过技术 - 避免不必要的计算
4. 提前退出策略 - 当部分结果已超过最优值时提前终止
5. 更稀疏的超时检查 - 减少检查开销</p>
<p>```python
import numpy as np
from rust_pyfunc import super_dtw_distance, fast_dtw_distance, dtw_distance</p>
<h1>创建两个时间序列</h1>
<p>s1 = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
s2 = np.array([1.1, 2.1, 3.1, 4.1, 5.1])</p>
<h1>比较三种实现的结果和性能</h1>
<p>import time</p>
<p>start = time.time()
result1 = dtw_distance(s1, s2)
time1 = time.time() - start</p>
<p>start = time.time()
result2 = fast_dtw_distance(s1, s2)
time2 = time.time() - start</p>
<p>start = time.time()
result3 = super_dtw_distance(s1, s2)
time3 = time.time() - start</p>
<p>print(f"标准DTW距离: {result1:.6f}, 耗时: {time1:.6f}秒")
print(f"快速DTW距离: {result2:.6f}, 耗时: {time2:.6f}秒")
print(f"超级DTW距离: {result3:.6f}, 耗时: {time3:.6f}秒")
print(f"fast加速比: {time1/time2:.2f}倍")
print(f"super加速比: {time1/time3:.2f}倍")
```</p></div>
                <a href="super_dtw_distance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="super_find_half_extreme_time.html">super_find_half_extreme_time</a></h3>
                <div><p>计算半极端时间的超级优化版本</p>
<p>与fast_find_half_extreme_time相比，该函数引入了以下额外优化：
1. SIMD加速 - 利用向量化操作加速计算
2. 高级缓存优化 - 通过预计算和数据布局进一步提高缓存命中率
3. 直接内存操作 - 减少边界检查和间接访问
4. 预先筛选 - 先过滤掉不可能的时间范围
5. 多线程并行 - 在可能的情况下使用并行计算</p></div>
                <a href="super_find_half_extreme_time.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="test_function.html">test_function</a></h3>
                <div><p>简单测试函数，确保模块导出正常工作</p></div>
                <a href="test_function.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="time_irreversibility_static_detailed.html">time_irreversibility_static_detailed</a></h3>
                <div><p>静态版-详细版：计算所有静态不可逆性指标</p></div>
                <a href="time_irreversibility_static_detailed.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="time_irreversibility_static_simple.html">time_irreversibility_static_simple</a></h3>
                <div><p>静态版-简略版：只计算时间不可逆指标 I_ord</p></div>
                <a href="time_irreversibility_static_simple.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="time_irreversibility_transfer_detailed.html">time_irreversibility_transfer_detailed</a></h3>
                <div><p>转移版-详细版：计算所有转移不可逆性指标</p></div>
                <a href="time_irreversibility_transfer_detailed.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="time_irreversibility_transfer_simple.html">time_irreversibility_transfer_simple</a></h3>
                <div><p>转移版-简略版：只计算转移不可逆指标 I_trans</p></div>
                <a href="time_irreversibility_transfer_simple.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="trade_peak_analysis.html">trade_peak_analysis</a></h3>
                <div><p>交易高峰模式分析函数</p>
<p>该函数用于分析交易数据中的高峰模式，包括：
1. 识别成交量的局部高峰(根据top_tier1百分比)
2. 在每个高峰的时间窗口内识别小峰(根据top_tier2百分比)
3. 计算17个统计指标来描述高峰-小峰的模式特征</p></div>
                <a href="trade_peak_analysis.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="transfer_entropy.html">transfer_entropy</a></h3>
                <div><p>计算从序列x到序列y的转移熵（Transfer Entropy）。
转移熵衡量了一个时间序列对另一个时间序列的影响程度，是一种非线性的因果关系度量。
具体来说，它测量了在已知x的过去k个状态的情况下，对y的当前状态预测能力的提升程度。</p></div>
                <a href="transfer_entropy.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="transfer_entropy_safe.html">transfer_entropy_safe</a></h3>
                <div><p>计算从序列 x 到序列 y 的转移熵（安全版本，可处理 NaN 值）</p>
<p>该函数计算从时间序列 x 到时间序列 y 的转移熵，用于量化 x 对 y 的因果影响。
与原版 transfer_entropy 不同，此版本能够安全处理包含 NaN 值的数据。</p>
<h1>Arguments</h1>
<ul>
<li><code>x_</code> - 源时间序列，可以包含 NaN 值</li>
<li><code>y_</code> - 目标时间序列，可以包含 NaN 值  </li>
<li><code>k</code> - 时间延迟参数</li>
<li><code>c</code> - 离散化的分箱数量</li>
</ul>
<h1>Returns</h1>
<p>转移熵值，如果数据不足或全为 NaN 则返回 0.0</p>
<h1>Examples</h1>
<p>```python
import numpy as np
import rust_pyfunc</p>
<h1>创建包含 NaN 的数据</h1>
<p>x = [1.0, 2.0, np.nan, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
y = [2.0, 3.0, 4.0, 5.0, np.nan, 7.0, 8.0, 9.0, 10.0, 11.0]</p>
<h1>安全计算转移熵（不会 panic）</h1>
<p>te = rust_pyfunc.transfer_entropy_safe(x, y, k=1, c=3)
print(f"转移熵: {te}")
```</p></div>
                <a href="transfer_entropy_safe.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="trend.html">trend</a></h3>
                <div><p>计算输入数组与自然数序列(1, 2, ..., n)之间的皮尔逊相关系数。
这个函数可以用来判断一个序列的趋势性，如果返回值接近1表示强上升趋势，接近-1表示强下降趋势。</p></div>
                <a href="trend.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="trend_2d.html">trend_2d</a></h3>
                <div><p>计算二维数组各行或各列的趋势性</p></div>
                <a href="trend_2d.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="trend_fast.html">trend_fast</a></h3>
                <div><p>这是trend函数的高性能版本，专门用于处理numpy.ndarray类型的float64数组。
使用了显式的SIMD指令和缓存优化处理，比普通版本更快。</p></div>
                <a href="trend_fast.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="vector_similarity_matrices.html">vector_similarity_matrices</a></h3>
                <div><p>超级优化的向量相似度矩阵计算（零拷贝 + SIMD + 对称性）</p>
<p>主要优化技术：
- 零拷贝输入：使用PyReadonlyArray1避免Python到Rust的数据拷贝
- SIMD向量化：使用AVX2指令集并行计算4个元素
- 对称性优化：只计算上三角矩阵，减少一半计算量
- 直接内存操作：直接写入numpy数组内存，避免中间分配
- 缓存友好：优化内存访问模式，提高缓存命中率</p></div>
                <a href="vector_similarity_matrices.html">查看详情</a>
            </div>
            
        </div>
        
        <div id="time_series" class="category">
            <h2 class="category-title">时间序列函数</h2>
            
        </div>
        
        <div id="other" class="category">
            <h2 class="category-title">其他函数</h2>
            
        </div>
    </div>
</div>

</body>
</html>