<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust PyFunc API文档</title>
    <link rel="stylesheet" href="static/style.css">
    <script src="static/search.js"></script>
</head>
<body>
    <div class="navbar">
        <h1 class="navbar-title">Rust PyFunc</h1>
        <p class="navbar-subtitle">高性能Python函数集合 - API文档</p>
    </div>
    
    
<div class="container">
    <div class="sidebar">
        <div class="search-container">
            <input type="text" id="search-input" placeholder="搜索函数...">
            <div id="search-results"></div>
        </div>
        
        <h2>函数分类</h2>
        <ul class="function-list">
            <li><a href="#text">文本处理</a></li>
            <li><a href="#sequence">序列分析</a></li>
            <li><a href="#statistics">统计分析</a></li>
            <li><a href="#time_series">时间序列</a></li>
            <li><a href="#other">其他函数</a></li>
        </ul>
    </div>
    
    <div class="content">
        <h1>API 文档</h1>
        <p>本文档提供了Rust PyFunc库中所有公开函数的详细说明和使用示例。这些示例基于真实的Python运行结果生成。</p>
        
        <div id="text" class="category">
            <h2 class="category-title">文本处理函数</h2>
            
            <div class="function-item">
                <h3 class="function-name"><a href="jaccard_similarity.html">jaccard_similarity</a></h3>
                <div><p>计算两个句子之间的Jaccard相似度。
Jaccard相似度是两个集合交集大小除以并集大小，用于衡量两个句子的相似程度。
这里将每个句子视为单词集合，忽略单词出现的顺序和频率。</p></div>
                <a href="jaccard_similarity.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="min_word_edit_distance.html">min_word_edit_distance</a></h3>
                <div><p>计算将一个句子转换为另一个句子所需的最少单词操作次数（添加/删除）。</p>
<h1>参数</h1>
<ul>
<li><code>str1</code> - 源句子</li>
<li><code>str2</code> - 目标句子</li>
</ul>
<h1>示例</h1>
<p>```python
from rust_pyfunc import min_word_edit_distance</p>
<h1>示例1：添加一个单词</h1>
<p>da = "We expect demand to increase"
db = "We expect worldwide demand to increase"
print(min_word_edit_distance(da, db))  # 输出: 1 (添加 "worldwide")</p>
<h1>示例2：多次修改</h1>
<p>dc = "We expect weakness in sales"
print(min_word_edit_distance(da, dc))  # 输出: 6 (删除3个单词，添加3个单词)
```</p></div>
                <a href="min_word_edit_distance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="vectorize_sentences.html">vectorize_sentences</a></h3>
                <div><p>将两个句子转换为词频向量。
生成的向量长度相同，等于两个句子中不同单词的总数。
向量中的每个位置对应一个单词，值表示该单词在句子中出现的次数。</p></div>
                <a href="vectorize_sentences.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="vectorize_sentences_list.html">vectorize_sentences_list</a></h3>
                <div><p>将多个句子转换为词频向量列表。
生成的所有向量长度相同，等于所有句子中不同单词的总数。
每个向量中的每个位置对应一个单词，值表示该单词在对应句子中出现的次数。</p></div>
                <a href="vectorize_sentences_list.html">查看详情</a>
            </div>
            
        </div>
        
        <div id="sequence" class="category">
            <h2 class="category-title">序列分析函数</h2>
            
            <div class="function-item">
                <h3 class="function-name"><a href="compute_max_eigenvalue.html">compute_max_eigenvalue</a></h3>
                <div><p>计算二维方阵的最大特征值和对应的特征向量
使用幂迭代法计算，不使用并行计算</p></div>
                <a href="compute_max_eigenvalue.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="find_follow_volume_sum_same_price.html">find_follow_volume_sum_same_price</a></h3>
                <div><p>计算每一行在其后time_window秒内具有相同volume（及可选相同price）的行的volume总和。</p></div>
                <a href="find_follow_volume_sum_same_price.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="find_follow_volume_sum_same_price_and_flag.html">find_follow_volume_sum_same_price_and_flag</a></h3>
                <div><p>无文档</p></div>
                <a href="find_follow_volume_sum_same_price_and_flag.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="find_half_energy_time.html">find_half_energy_time</a></h3>
                <div><p>计算每个时间点价格达到时间窗口内最终能量一半所需的时间。</p>
<p>该函数首先计算时间窗口结束时的能量（价格变动的绝对值比率），
然后计算第一次达到该能量一半所需的时间。</p>
<h1>参数说明</h1>
<ul>
<li><code>times</code> - 时间戳数组（单位：秒）</li>
<li><code>prices</code> - 价格数组</li>
<li><code>time_window</code> - 时间窗口大小（单位：秒），默认为5.0</li>
</ul>
<h1>返回值</h1>
<p>浮点数数组，表示每个时间点达到最终能量一半所需的时间（秒）。
如果在时间窗口内未达到一半能量，则返回time_window值。
如果最终能量为0，则返回0。</p>
<h1>特殊情况处理</h1>
<ul>
<li>当价格为NaN或Inf时，对应结果为NaN</li>
<li>当最终能量为0时，结果为0</li>
<li>当时间窗口内无法计算出最终能量时，结果为time_window</li>
</ul>
<h1>性能</h1>
<p>该函数使用并行处理加速计算，在大规模数据集上比等效的Python实现快约20-100倍。</p>
<h1>示例</h1>
<p>```python
import pandas as pd
import numpy as np
from rust_pyfunc import find_half_energy_time</p>
<h1>创建示例DataFrame</h1>
<p>df = pd.DataFrame({
    'exchtime': [1.0, 1.1, 1.2, 1.3, 1.4],
    'price': [10.0, 10.2, 10.5, 10.3, 10.1]
})</p>
<h1>计算达到一半能量所需时间</h1>
<p>df['half_energy_time'] = find_half_energy_time(
    df['exchtime'].values,
    df['price'].values,
    time_window=5.0
)
print(df)
```</p></div>
                <a href="find_half_energy_time.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="find_half_extreme_time.html">find_half_extreme_time</a></h3>
                <div><p>计算每一行在其后指定时间窗口内的价格变动能量，并找出首次达到最终能量一半时所需的时间。</p></div>
                <a href="find_half_extreme_time.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="find_local_peaks_within_window.html">find_local_peaks_within_window</a></h3>
                <div><p>查找时间序列中价格在指定时间窗口内为局部最大值的点。</p></div>
                <a href="find_local_peaks_within_window.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="find_max_range_product.html">find_max_range_product</a></h3>
                <div><p>在数组中找到一对索引(x, y)，使得min(arr[x], arr[y]) * |x-y|的值最大。
这个函数可以用来找到数组中距离最远的两个元素，同时考虑它们的最小值。</p></div>
                <a href="find_max_range_product.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="identify_segments.html">identify_segments</a></h3>
                <div><p>识别数组中的连续相等值段，并为每个段分配唯一标识符。
每个连续相等的值构成一个段，第一个段标识符为1，第二个为2，以此类推。</p></div>
                <a href="identify_segments.html">查看详情</a>
            </div>
            
        </div>
        
        <div id="statistics" class="category">
            <h2 class="category-title">统计分析函数</h2>
            
            <div class="function-item">
                <h3 class="function-name"><a href="PriceTree.html">PriceTree</a></h3>
                <div><p>无文档</p></div>
                <a href="PriceTree.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="PriceTreeViz.html">PriceTreeViz</a></h3>
                <div><p>无文档</p></div>
                <a href="PriceTreeViz.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="RollingFutureAccessor.html">RollingFutureAccessor</a></h3>
                <div><p>用于在pandas DataFrame或Series上实现向后滚动窗口计算的访问器。</p>
<h2>支持的统计量类型：</h2>
<ul>
<li>mean: 计算后面窗口内的均值</li>
<li>sum: 计算后面窗口内的总和</li>
<li>max: 计算后面窗口内的最大值</li>
<li>min: 计算后面窗口内的最小值</li>
<li>std: 计算后面窗口内的标准差</li>
<li>median: 计算后面窗口内的中位数</li>
<li>count: 计算后面窗口内的数据点数量</li>
<li>rank: 计算当前值在后面窗口内的分位数（0到1之间）</li>
<li>skew: 计算后面窗口的偏度</li>
<li>trend_time: 计算后面窗口内数据序列与时间序列的相关系数</li>
<li>trend_oneton: 计算后面窗口内数据序列与1到n序列的相关系数（忽略时间间隔）</li>
<li>last: 计算后面窗口内的最后一个值</li>
</ul>
<p>注意：所有计算都不包括当前时间点的值，只考虑后面窗口内的值</p>
<h2>使用方法：</h2>
<blockquote>
<blockquote>
<blockquote>
<p>import pandas as pd
from rust_pyfunc import rolling_future</p>
<h1>DataFrame示例</h1>
<p>df = pd.DataFrame({
...     'time': pd.date_range('2024-01-01', periods=5, freq='s'),
...     'value': [1, 2, 3, 4, 5]
... })
df.set_index('time', inplace=True)
df.rolling_future('2s').mean()  # 计算每个时间点之后2秒内的均值
df.rolling_future('2s').rank()  # 计算每个值在后面2秒内的分位数</p>
<h1>Series示例</h1>
<p>s = pd.Series([1, 2, 3, 4, 5], 
...               index=pd.date_range('2024-01-01', periods=5, freq='s'))
s.rolling_future('2s').mean()  # 计算每个时间点之后2秒内的均值
s.rolling_future('2s').trend_time()  # 计算后面2秒内的趋势</p>
</blockquote>
</blockquote>
</blockquote></div>
                <a href="RollingFutureAccessor.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="analyze_retreat_advance.html">analyze_retreat_advance</a></h3>
                <div><p>分析股票交易中的"以退为进"现象</p>
<p>该函数分析当价格触及某个局部高点后回落，然后在该价格的异常大挂单量消失后
成功突破该价格的现象。</p></div>
                <a href="analyze_retreat_advance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="analyze_retreat_advance_v2.html">analyze_retreat_advance_v2</a></h3>
                <div><p>分析股票交易中的"以退为进"现象（纳秒版本）</p>
<p>该函数分析当价格触及某个局部高点后回落，然后在该价格的异常大挂单量消失后
成功突破该价格的现象。该版本包含局部高点去重功能，避免在同一价格水平的
连续成交中重复识别相同的"以退为进"过程。</p></div>
                <a href="analyze_retreat_advance_v2.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="brachistochrone_curve.html">brachistochrone_curve</a></h3>
                <div><p>计算最速曲线（投掷线）并返回x_series对应的y坐标</p></div>
                <a href="brachistochrone_curve.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="brachistochrone_curve_v2.html">brachistochrone_curve_v2</a></h3>
                <div><p>修正版最速曲线函数，确保终点严格一致  </p>
<p>此函数解决了原版brachistochrone_curve终点不一致的问题
通过强制约束终点坐标，确保数学正确性</p></div>
                <a href="brachistochrone_curve_v2.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_base_entropy.html">calculate_base_entropy</a></h3>
                <div><p>计算基准熵 - 基于到当前时间点为止的订单分布计算香农熵</p>
<p>参数:
* exchtime: 交易时间数组（纳秒时间戳）
* order: 订单号数组
* volume: 成交量数组
* index: 计算熵值的当前索引位置</p>
<p>返回:
* 基准熵值</p></div>
                <a href="calculate_base_entropy.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_large_order_nearby_small_order_time_gap.html">calculate_large_order_nearby_small_order_time_gap</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_large_order_nearby_small_order_time_gap.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_lyapunov_exponent.html">calculate_lyapunov_exponent</a></h3>
                <div><p>统一的Lyapunov指数计算函数</p></div>
                <a href="calculate_lyapunov_exponent.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_order_time_gap_and_price_percentile_ultra_sorted.html">calculate_order_time_gap_and_price_percentile_ultra_sorted</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_order_time_gap_and_price_percentile_ultra_sorted.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_order_time_gap_and_price_percentile_ultra_sorted_v2.html">calculate_order_time_gap_and_price_percentile_ultra_sorted_v2</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_order_time_gap_and_price_percentile_ultra_sorted_v2.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_shannon_entropy_change.html">calculate_shannon_entropy_change</a></h3>
                <div><p>计算价格变化后的香农熵变</p></div>
                <a href="calculate_shannon_entropy_change.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_shannon_entropy_change_at_low.html">calculate_shannon_entropy_change_at_low</a></h3>
                <div><p>在价格创新低时计算香农熵变</p>
<p>参数:
* exchtime: 交易时间数组
* order: 订单号数组
* volume: 成交量数组
* price: 价格数组
* window_seconds: 时间窗口大小（秒）
* bottom_k: 如果提供，则只计算价格最低的k个点的熵变，默认为None（计算所有价格创新低点）</p>
<p>返回:
* 香农熵变数组，只在价格创新低时有值，其他位置为NaN</p></div>
                <a href="calculate_shannon_entropy_change_at_low.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_trade_time_gap_and_price_percentile_ultra_sorted.html">calculate_trade_time_gap_and_price_percentile_ultra_sorted</a></h3>
                <div><p>无文档</p></div>
                <a href="calculate_trade_time_gap_and_price_percentile_ultra_sorted.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="calculate_window_entropy.html">calculate_window_entropy</a></h3>
                <div><p>计算窗口熵 - 基于从当前时间点到未来指定时间窗口内的订单分布计算香农熵</p>
<p>参数:
* exchtime: 交易时间数组（纳秒时间戳）
* order: 订单号数组
* volume: 成交量数组
* index: 计算熵值的当前索引位置
* window_seconds: 向前查看的时间窗口大小，单位为秒</p>
<p>返回:
* 窗口熵值</p></div>
                <a href="calculate_window_entropy.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="corrwith.html">corrwith</a></h3>
                <div><p>计算两个DataFrame对应列或行之间的相关系数。</p>
<p>这个函数是pandas的corrwith方法的Rust实现包装，用于计算两个DataFrame中对应列（或行）
之间的皮尔逊相关系数。会自动处理两个DataFrame的列名（或行名）匹配情况。</p></div>
                <a href="corrwith.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="dataframe_corrwith.html">dataframe_corrwith</a></h3>
                <div><p>计算两个数据框对应列的相关系数。</p>
<p>这个函数类似于pandas中的df.corrwith(df1)，计算两个数据框中对应列之间的皮尔逊相关系数。
相关系数范围为[-1, 1]，其中：
- 1表示完全正相关
- -1表示完全负相关
- 0表示无相关性</p></div>
                <a href="dataframe_corrwith.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="dtw_distance.html">dtw_distance</a></h3>
                <div><p>DTW（动态时间规整）是一种测量两个时间序列相似度的方法。
该算法计算两个可能长度不同、tempo不同的时间序列间的最优匹配。</p></div>
                <a href="dtw_distance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="factor_correlation_by_date.html">factor_correlation_by_date</a></h3>
                <div><p>按日期计算ret和fac的分组相关系数</p>
<h1>Arguments</h1>
<ul>
<li><code>dates</code> - 日期时间戳数组</li>
<li><code>ret</code> - 收益率数组</li>
<li><code>fac</code> - 因子值数组</li>
</ul>
<h1>Returns</h1>
<ul>
<li>(unique_dates, full_corr, low_corr, high_corr) - 四个数组</li>
<li>unique_dates: 唯一日期</li>
<li>full_corr: 每日全体数据的ret和fac排序值相关系数</li>
<li>low_corr: 每日fac小于中位数部分的ret和fac排序值相关系数</li>
<li>high_corr: 每日fac大于中位数部分的ret和fac排序值相关系数</li>
</ul></div>
                <a href="factor_correlation_by_date.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="factor_grouping.html">factor_grouping</a></h3>
                <div><p>按日期对因子值进行分组</p>
<h1>Arguments</h1>
<ul>
<li><code>dates</code> - 日期时间戳数组</li>
<li><code>factors</code> - 因子值数组</li>
<li><code>groups_num</code> - 分组数量，默认为10</li>
</ul>
<h1>Returns</h1>
<ul>
<li>每个观测值对应的分组号(1到groups_num)</li>
</ul></div>
                <a href="factor_grouping.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_dtw_distance.html">fast_dtw_distance</a></h3>
                <div><p>优化版DTW距离函数，使用以下技术提升性能：
1. 使用一维数组代替二维数组，减少内存分配和间接访问
2. 提前计算常用值，减少重复计算
3. 对于窗口计算进行更高效的实现
4. 优化内存访问模式，提高缓存命中率
5. 智能初始化窗口内单元格，避免无限值问题
6. 自动调整radius大小，确保计算结果有效</p>
<p>```python
import numpy as np
from rust_pyfunc import fast_dtw_distance, dtw_distance</p>
<h1>创建两个时间序列</h1>
<p>s1 = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
s2 = np.array([1.1, 2.1, 3.1, 4.1, 5.1])</p>
<h1>比较两种实现的结果和性能</h1>
<p>import time</p>
<p>start = time.time()
result1 = dtw_distance(s1, s2)
time1 = time.time() - start</p>
<p>start = time.time()
result2 = fast_dtw_distance(s1, s2)
time2 = time.time() - start</p>
<p>print(f"标准DTW距离: {result1:.6f}, 耗时: {time1:.6f}秒")
print(f"快速DTW距离: {result2:.6f}, 耗时: {time2:.6f}秒")
print(f"加速比: {time1/time2:.2f}倍")
```</p></div>
                <a href="fast_dtw_distance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_find_half_extreme_time.html">fast_find_half_extreme_time</a></h3>
                <div><p>计算半极端时间的优化版本</p>
<p>该函数针对find_half_extreme_time进行了多项优化：
1. 预计算和缓存 - 避免重复计算时间差和比率
2. 数据布局优化 - 改进内存访问模式
3. 条件分支优化 - 减少分支预测失败
4. 界限优化 - 提前确定搜索范围</p></div>
                <a href="fast_find_half_extreme_time.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_inner_join_dataframes.html">fast_inner_join_dataframes</a></h3>
                <div><p>高性能DataFrame内连接，专门优化Python DataFrame处理</p></div>
                <a href="fast_inner_join_dataframes.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_inner_join_df.html">fast_inner_join_df</a></h3>
                <div><p>快速内连接的便捷函数</p></div>
                <a href="fast_inner_join_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_left_join_df.html">fast_left_join_df</a></h3>
                <div><p>快速左连接的便捷函数</p></div>
                <a href="fast_left_join_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_merge.html">fast_merge</a></h3>
                <div><p>高性能merge函数，支持数据表连接操作</p></div>
                <a href="fast_merge.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_merge_df.html">fast_merge_df</a></h3>
                <div><p>高性能的DataFrame merge函数</p>
<p>这是rust_pyfunc.fast_merge的DataFrame封装版本，可以直接传入DataFrame
并返回标准的DataFrame结果。</p></div>
                <a href="fast_merge_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_merge_df.html">fast_merge_df</a></h3>
                <div><p>高性能的DataFrame merge函数</p>
<p>这是rust_pyfunc.fast_merge的DataFrame封装版本，可以直接传入DataFrame
并返回标准的DataFrame结果。</p></div>
                <a href="fast_merge_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_merge_df.html">fast_merge_df</a></h3>
                <div><p>高性能的DataFrame merge函数</p>
<p>这是rust_pyfunc.fast_merge的DataFrame封装版本，可以直接传入DataFrame
并返回标准的DataFrame结果。</p></div>
                <a href="fast_merge_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_merge_mixed.html">fast_merge_mixed</a></h3>
                <div><p>高性能merge函数，支持字符串和数值类型的连接键</p></div>
                <a href="fast_merge_mixed.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_outer_join_df.html">fast_outer_join_df</a></h3>
                <div><p>快速外连接的便捷函数</p></div>
                <a href="fast_outer_join_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="fast_right_join_df.html">fast_right_join_df</a></h3>
                <div><p>快速右连接的便捷函数</p></div>
                <a href="fast_right_join_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="local_correlation.html">local_correlation</a></h3>
                <div><p>计算价格序列的局部相关性分析</p>
<p>对于每个价格点，向前取x个值作为局部序列，然后分别向前和向后搜索，
找到与当前局部序列相关性最大和最小的位置，并计算间隔行数和volume总和。</p></div>
                <a href="local_correlation.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="mark_follow_groups.html">mark_follow_groups</a></h3>
                <div><p>标记每一行在其后0.1秒内具有相同price和volume的行组。
对于同一个时间窗口内的相同交易组，标记相同的组号。
组号从1开始递增，每遇到一个新的交易组就分配一个新的组号。</p></div>
                <a href="mark_follow_groups.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="mark_follow_groups_with_flag.html">mark_follow_groups_with_flag</a></h3>
                <div><p>标记每一行在其后time_window秒内具有相同flag、price和volume的行组。
对于同一个时间窗口内的相同交易组，标记相同的组号。
组号从1开始递增，每遇到一个新的交易组就分配一个新的组号。</p></div>
                <a href="mark_follow_groups_with_flag.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="max_range_loop.html">max_range_loop</a></h3>
                <div><p>计算序列中每个位置结尾的最长连续子序列长度，其中子序列的最大值在该位置。</p></div>
                <a href="max_range_loop.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="min_range_loop.html">min_range_loop</a></h3>
                <div><p>计算序列中每个位置结尾的最长连续子序列长度，其中子序列的最小值在该位置。</p></div>
                <a href="min_range_loop.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="ols.html">ols</a></h3>
                <div><p>普通最小二乘(OLS)回归。
用于拟合线性回归模型 y = Xβ + ε，其中β是要估计的回归系数。</p></div>
                <a href="ols.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="ols_predict.html">ols_predict</a></h3>
                <div><p>使用已有数据和响应变量，对新的数据点进行OLS线性回归预测。</p></div>
                <a href="ols_predict.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="ols_residuals.html">ols_residuals</a></h3>
                <div><p>计算普通最小二乘(OLS)回归的残差序列。
残差表示实际观测值与模型预测值之间的差异: ε = y - Xβ。</p></div>
                <a href="ols_residuals.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="order_contamination.html">order_contamination</a></h3>
                <div><p>优化版订单浸染函数 - 高性能单线程版本</p>
<h1>参数</h1>
<ul>
<li>exchtime: 成交时间数组（纳秒）</li>
<li>order: 订单编号数组</li>
<li>volume: 成交量数组  </li>
<li>top_percentile: 大单百分比阈值 (1-100)，表示前x%，默认10表示前10%</li>
<li>time_window_seconds: 时间窗口（秒），默认1秒</li>
</ul>
<h1>返回</h1>
<p>浸染后的订单编号数组</p></div>
                <a href="order_contamination.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="order_contamination_parallel.html">order_contamination_parallel</a></h3>
                <div><p>并行版本的订单浸染函数（使用5核心，适用于大数据量）</p></div>
                <a href="order_contamination_parallel.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="order_neighborhood_analysis.html">order_neighborhood_analysis</a></h3>
                <div><p>超级高速订单邻域分析函数 - 为13万数据优化</p>
<p>激进优化策略：
1. 预计算邻域索引表
2. 批量SIMD计算
3. 内存预分配避免动态分配
4. 分层并行处理
5. 零拷贝数据传递</p></div>
                <a href="order_neighborhood_analysis.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup.html">query_backup</a></h3>
                <div><p>无文档</p></div>
                <a href="query_backup.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_columns_range_with_filter.html">query_backup_columns_range_with_filter</a></h3>
                <div><p>查询备份文件中的指定列范围，支持过滤</p>
<p>参数:
- backup_file: 备份文件路径
- column_start: 开始列索引（包含）
- column_end: 结束列索引（包含）
- dates: 可选的日期过滤列表
- codes: 可选的代码过滤列表</p>
<p>返回:
包含numpy数组的字典: {"date": 日期数组, "code": 代码数组, "factors": 指定列范围的因子值数组}</p></div>
                <a href="query_backup_columns_range_with_filter.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_factor_only.html">query_backup_factor_only</a></h3>
                <div><p>查询备份文件中的指定列因子值（纯因子值数组）</p>
<p>参数:
- backup_file: 备份文件路径
- column_index: 要读取的因子列索引（0表示第一列因子值）</p>
<p>返回:
只包含因子值的numpy数组</p></div>
                <a href="query_backup_factor_only.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_factor_only_ultra_fast.html">query_backup_factor_only_ultra_fast</a></h3>
                <div><p>超高速查询备份文件中的指定列因子值</p>
<p>参数:
- backup_file: 备份文件路径
- column_index: 要读取的因子列索引（0表示第一列因子值）</p>
<p>返回:
只包含因子值的numpy数组</p></div>
                <a href="query_backup_factor_only_ultra_fast.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_factor_only_with_filter.html">query_backup_factor_only_with_filter</a></h3>
                <div><p>查询备份文件中的指定列因子值（纯因子值数组），支持过滤</p>
<p>参数:
- backup_file: 备份文件路径
- column_index: 要读取的因子列索引（0表示第一列因子值）
- dates: 可选的日期过滤列表
- codes: 可选的代码过滤列表</p>
<p>返回:
只包含因子值的numpy数组</p></div>
                <a href="query_backup_factor_only_with_filter.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_fast.html">query_backup_fast</a></h3>
                <div><p>高速并行备份查询函数，专门优化大文件读取</p></div>
                <a href="query_backup_fast.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_single_column.html">query_backup_single_column</a></h3>
                <div><p>查询备份文件中的指定列</p>
<p>参数:
- backup_file: 备份文件路径
- column_index: 要读取的因子列索引（0表示第一列因子值）</p>
<p>返回:
包含三个numpy数组的字典: {"date": 日期数组, "code": 代码数组, "factor": 指定列的因子值数组}</p></div>
                <a href="query_backup_single_column.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="query_backup_single_column_with_filter.html">query_backup_single_column_with_filter</a></h3>
                <div><p>查询备份文件中的指定列，支持过滤</p>
<p>参数:
- backup_file: 备份文件路径
- column_index: 要读取的因子列索引（0表示第一列因子值）
- dates: 可选的日期过滤列表
- codes: 可选的代码过滤列表</p>
<p>返回:
包含三个numpy数组的字典: {"date": 日期数组, "code": 代码数组, "factor": 指定列的因子值数组}</p></div>
                <a href="query_backup_single_column_with_filter.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rank_axis0_df.html">rank_axis0_df</a></h3>
                <div><p>高性能的DataFrame rank函数，支持axis=0（沿列方向排名）</p>
<p>通过转置实现沿列方向的排名，同样具有高性能优势。</p></div>
                <a href="rank_axis0_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rank_axis0_df.html">rank_axis0_df</a></h3>
                <div><p>高性能的DataFrame rank函数，支持axis=0（沿列方向排名）</p>
<p>通过转置实现沿列方向的排名，同样具有高性能优势。</p></div>
                <a href="rank_axis0_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rank_axis1.html">rank_axis1</a></h3>
                <div><p>高性能的DataFrame rank函数，支持axis=1（沿行方向排名）
相比pandas的rank函数能显著提升性能</p></div>
                <a href="rank_axis1.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rank_axis1_df.html">rank_axis1_df</a></h3>
                <div><p>高性能的DataFrame rank函数，支持axis=1（沿行方向排名）</p>
<p>这是rust_pyfunc.rank_axis1的DataFrame封装版本，可以直接传入DataFrame
并返回保持原有索引和列名的DataFrame结果。</p></div>
                <a href="rank_axis1_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rank_axis1_df.html">rank_axis1_df</a></h3>
                <div><p>高性能的DataFrame rank函数，支持axis=1（沿行方向排名）</p>
<p>这是rust_pyfunc.rank_axis1的DataFrame封装版本，可以直接传入DataFrame
并返回保持原有索引和列名的DataFrame结果。</p></div>
                <a href="rank_axis1_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rank_axis1_df.html">rank_axis1_df</a></h3>
                <div><p>高性能的DataFrame rank函数，支持axis=1（沿行方向排名）</p>
<p>这是rust_pyfunc.rank_axis1的DataFrame封装版本，可以直接传入DataFrame
并返回保持原有索引和列名的DataFrame结果。</p></div>
                <a href="rank_axis1_df.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_cv.html">rolling_cv</a></h3>
                <div><p>计算价格序列的滚动变异系数(CV)。</p>
<p>对于位置i，从数据范围[i-lookback+1, i]中每隔interval个点取样，
然后计算相邻样本之间的对数收益率（后面的价格除以前面的价格的对数），
最后计算这些收益率的变异系数（标准差除以均值）。</p></div>
                <a href="rolling_cv.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_dtw_distance.html">rolling_dtw_distance</a></h3>
                <div><p>计算每个大单与其临近小单之间的时间间隔均值。</p></div>
                <a href="rolling_dtw_distance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_qcv.html">rolling_qcv</a></h3>
                <div><p>计算价格序列的滚动四分位变异系数(QCV)。</p>
<p>对于位置i，从数据范围[i-lookback+1, i]中每隔interval个点取样，
然后计算相邻样本之间的对数收益率（后面的价格除以前面的价格的对数），
最后计算这些收益率的四分位变异系数（四分位间距除以中位数的绝对值）。
这种方法对异常值和均值接近零的情况更加稳健。</p></div>
                <a href="rolling_qcv.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_volatility.html">rolling_volatility</a></h3>
                <div><p>计算价格序列的滚动波动率。</p>
<p>对于位置i，从数据范围[i-lookback+1, i]中每隔interval个点取样，
然后计算相邻样本之间的对数收益率（后面的价格除以前面的价格的对数），
最后计算这些收益率的标准差作为波动率。</p></div>
                <a href="rolling_volatility.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="rolling_window_stat.html">rolling_window_stat</a></h3>
                <div><p>计算时间序列在指定时间窗口内向后滚动的统计量。
对于每个时间点，计算该点之后指定时间窗口内所有数据的指定统计量。</p></div>
                <a href="rolling_window_stat.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="run_pools_queue.html">run_pools_queue</a></h3>
                <div><p>无文档</p></div>
                <a href="run_pools_queue.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="segment_and_correlate.html">segment_and_correlate</a></h3>
                <div><p>序列分段和相关系数计算函数</p>
<p>输入两个等长的序列，根据大小关系进行分段，然后计算每段内的相关系数</p></div>
                <a href="segment_and_correlate.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="sum_as_string.html">sum_as_string</a></h3>
                <div><p>Formats the sum of two numbers as string.</p></div>
                <a href="sum_as_string.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="super_dtw_distance.html">super_dtw_distance</a></h3>
                <div><p>超级优化版DTW距离函数，使用以下高级技术提升性能：
1. 内存预分配 - 减少运行时内存分配
2. 更精细的内存访问优化 - 提高缓存命中率
3. 基于启发式的跳过技术 - 避免不必要的计算
4. 提前退出策略 - 当部分结果已超过最优值时提前终止
5. 更稀疏的超时检查 - 减少检查开销</p>
<p>```python
import numpy as np
from rust_pyfunc import super_dtw_distance, fast_dtw_distance, dtw_distance</p>
<h1>创建两个时间序列</h1>
<p>s1 = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
s2 = np.array([1.1, 2.1, 3.1, 4.1, 5.1])</p>
<h1>比较三种实现的结果和性能</h1>
<p>import time</p>
<p>start = time.time()
result1 = dtw_distance(s1, s2)
time1 = time.time() - start</p>
<p>start = time.time()
result2 = fast_dtw_distance(s1, s2)
time2 = time.time() - start</p>
<p>start = time.time()
result3 = super_dtw_distance(s1, s2)
time3 = time.time() - start</p>
<p>print(f"标准DTW距离: {result1:.6f}, 耗时: {time1:.6f}秒")
print(f"快速DTW距离: {result2:.6f}, 耗时: {time2:.6f}秒")
print(f"超级DTW距离: {result3:.6f}, 耗时: {time3:.6f}秒")
print(f"fast加速比: {time1/time2:.2f}倍")
print(f"super加速比: {time1/time3:.2f}倍")
```</p></div>
                <a href="super_dtw_distance.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="super_find_half_extreme_time.html">super_find_half_extreme_time</a></h3>
                <div><p>计算半极端时间的超级优化版本</p>
<p>与fast_find_half_extreme_time相比，该函数引入了以下额外优化：
1. SIMD加速 - 利用向量化操作加速计算
2. 高级缓存优化 - 通过预计算和数据布局进一步提高缓存命中率
3. 直接内存操作 - 减少边界检查和间接访问
4. 预先筛选 - 先过滤掉不可能的时间范围
5. 多线程并行 - 在可能的情况下使用并行计算</p></div>
                <a href="super_find_half_extreme_time.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="test_function.html">test_function</a></h3>
                <div><p>简单测试函数，确保模块导出正常工作</p></div>
                <a href="test_function.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="trade_peak_analysis.html">trade_peak_analysis</a></h3>
                <div><p>交易高峰模式分析函数</p>
<p>该函数用于分析交易数据中的高峰模式，包括：
1. 识别成交量的局部高峰(根据top_tier1百分比)
2. 在每个高峰的时间窗口内识别小峰(根据top_tier2百分比)
3. 计算16个统计指标来描述高峰-小峰的模式特征</p></div>
                <a href="trade_peak_analysis.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="transfer_entropy.html">transfer_entropy</a></h3>
                <div><p>计算从序列x到序列y的转移熵（Transfer Entropy）。
转移熵衡量了一个时间序列对另一个时间序列的影响程度，是一种非线性的因果关系度量。
具体来说，它测量了在已知x的过去k个状态的情况下，对y的当前状态预测能力的提升程度。</p></div>
                <a href="transfer_entropy.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="trend.html">trend</a></h3>
                <div><p>计算输入数组与自然数序列(1, 2, ..., n)之间的皮尔逊相关系数。
这个函数可以用来判断一个序列的趋势性，如果返回值接近1表示强上升趋势，接近-1表示强下降趋势。</p></div>
                <a href="trend.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="trend_2d.html">trend_2d</a></h3>
                <div><p>计算二维数组各行或各列的趋势性</p></div>
                <a href="trend_2d.html">查看详情</a>
            </div>
            
            <div class="function-item">
                <h3 class="function-name"><a href="trend_fast.html">trend_fast</a></h3>
                <div><p>这是trend函数的高性能版本，专门用于处理numpy.ndarray类型的float64数组。
使用了显式的SIMD指令和缓存优化处理，比普通版本更快。</p></div>
                <a href="trend_fast.html">查看详情</a>
            </div>
            
        </div>
        
        <div id="time_series" class="category">
            <h2 class="category-title">时间序列函数</h2>
            
        </div>
        
        <div id="other" class="category">
            <h2 class="category-title">其他函数</h2>
            
        </div>
    </div>
</div>

</body>
</html>